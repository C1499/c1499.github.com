<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>饼干大超人</title>
  
  <subtitle>给时光以生命，给岁月以文明</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://04071011.xyz/"/>
  <updated>2020-12-30T12:43:28.524Z</updated>
  <id>https://04071011.xyz/</id>
  
  <author>
    <name>Simone</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>电商项目记录 - Java项目 - 2020</title>
    <link href="https://04071011.xyz/2020/12/18/%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://04071011.xyz/2020/12/18/电商项目记录/</id>
    <published>2020-12-18T05:56:47.000Z</published>
    <updated>2020-12-30T12:43:28.524Z</updated>
    
    <content type="html"><![CDATA[<h1 id="电商平台"><a href="#电商平台" class="headerlink" title="电商平台"></a>电商平台</h1><p>学习了很久的java，说的算完整的项目也就是一个博客项目。第四年打算做一个电商项目练习一下学习成果。</p><h2 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h2><ol><li>先安装了centos6，在里面搭建环境，以及windows系统的环境准备。安装java、tomcat、maven、vsftpd、git、Nginx、Mysql。</li><li>设计数据库表</li></ol><h3 id="vsftpd-linux"><a href="#vsftpd-linux" class="headerlink" title="vsftpd(linux)"></a>vsftpd(linux)</h3><p>前面的java、tomcat、maven基本上都是了解过的，这里记录一下新出现的软件工具。</p><ol><li>vsftpd是“very secure FTP daemon”的缩写，是一个ftp服务器软件。</li><li>FTP协议分为两种一种是PORT方式（主动式），一种是PASV方式（被动式）。<ul><li>PORT（主动）方式连接过程是，客户端向服务器端FTP端口（默认21）发送链接请求，服务器接收请求建立一条命令链路。<br>当需要传送数据时，客户端在命令链路上用 PORT命令告诉服务器：“我打开了xx端口，你过来连接我”。于是服务器从20端口向客户端的xx端口发送连接请求，建立一条数据链路来传送数据。</li><li>PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。<br>当需要传送数据时，服务器在命令链路上用 PASV命令告诉客户端：“我打开了xx端口，你过来连接我”。于是客户端向服务器的xx端口发送连接请求，建立一条数据链路来传送数据。</li></ul></li><li>常用命令：<ul><li>sudo service vsftpd start</li><li>sudo service vsftpd stop</li><li>sudo service vsftpd restart<h3 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h3></li></ul></li><li>Nginx是一款轻量级Web服务器、也是一款反向代理服务器。</li><li>具体实现：1.可直接支持Rails和PHP的程序 2.可作为HTTP反向代理服务器 3.作为负载均衡服务器 4.作为邮件代理服务器 5.帮助实现前端动静分离</li><li>常用命令<ul><li>安装路径下/nginx/sbin/nginx -t  :测试配置文件</li><li>安装路径下/nginx/sbin/nginx      :启动命令</li><li>安装路径下/nginx/sbin/nginx -s stop 或者 nginx -s quit    :停止命令</li><li>安装路径下/nginx/sbin/nginx -s reload     :重启命令<h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3>记录我从中学到的linux命令</li></ul></li><li>rpm -qa|grep xxxx :这条命令是判断是否安装了xx软件，返回已安装xx软件的版本号</li><li>mkdir xxx :创建一个文件夹</li><li>cp -r xx ss/ :拷贝xx文件夹所有内容到ss目录下</li><li>ps -ef|grep xxxx :查看xxxx进程</li><li>kill -HUP  xxx进程号  :查看到进程号再使用此命令达到平滑重启<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3></li><li>权限：dql-select,dml-insert update delete ddl-create table create view dcl-grant</li><li>mysql -u root -p :Linux下进入MySQL</li><li>select user,host,password from mysql.user 查看当前mysql的用户</li><li>set password for <a href="mailto:root@127.0.0.1" target="_blank" rel="noopener">root@127.0.0.1</a>=password(‘yourpassword’) :修改root密码</li></ol><h3 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h3><h4 id="用户表-user"><a href="#用户表-user" class="headerlink" title="用户表(user)"></a>用户表(user)</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">用户id</td></tr><tr><td style="text-align:center">username</td><td style="text-align:center">varchar</td><td style="text-align:center">用户名</td></tr><tr><td style="text-align:center">password</td><td style="text-align:center">varchar</td><td style="text-align:center">密码</td></tr><tr><td style="text-align:center">email</td><td style="text-align:center">varchar</td><td style="text-align:center">邮箱</td></tr><tr><td style="text-align:center">phone</td><td style="text-align:center">varchar</td><td style="text-align:center">手机号</td></tr><tr><td style="text-align:center">question</td><td style="text-align:center">varchar</td><td style="text-align:center">密保问题</td></tr><tr><td style="text-align:center">answer</td><td style="text-align:center">varchar</td><td style="text-align:center">密保答案</td></tr><tr><td style="text-align:center">role</td><td style="text-align:center">int</td><td style="text-align:center">用户角色</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><ol><li>在数据库中要讲用户名设置一个唯一索引unique,保证数据唯一性。</li><li>用户角色，不同数字代表不同角色。</li></ol><h4 id="分类表-category"><a href="#分类表-category" class="headerlink" title="分类表(category)"></a>分类表(category)</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">用户id</td></tr><tr><td style="text-align:center">parent_id</td><td style="text-align:center">int</td><td style="text-align:center">类别ID</td></tr><tr><td style="text-align:center">name</td><td style="text-align:center">varchar</td><td style="text-align:center">类别名称</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">tinyint</td><td style="text-align:center">类别状态</td></tr><tr><td style="text-align:center">sort_order</td><td style="text-align:center">int</td><td style="text-align:center">排序编号</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><ol><li>parent_id的值为0代表根节点。为其他数据的id值时，代表为那条数据的子节点。</li><li>status代表当前分类是否正常被使用</li></ol><h4 id="产品表-product"><a href="#产品表-product" class="headerlink" title="产品表(product)"></a>产品表(product)</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">商品id</td></tr><tr><td style="text-align:center">category_id</td><td style="text-align:center">int</td><td style="text-align:center">商品分类</td></tr><tr><td style="text-align:center">name</td><td style="text-align:center">varchar</td><td style="text-align:center">商品名称</td></tr><tr><td style="text-align:center">subtitile</td><td style="text-align:center">varchar</td><td style="text-align:center">商品副标题</td></tr><tr><td style="text-align:center">main_image</td><td style="text-align:center">varchar</td><td style="text-align:center">商品主图，url相对地址</td></tr><tr><td style="text-align:center">sub_images</td><td style="text-align:center">test</td><td style="text-align:center">商品子图图片地址，json格式</td></tr><tr><td style="text-align:center">detail</td><td style="text-align:center">text</td><td style="text-align:center">商品描述</td></tr><tr><td style="text-align:center">price</td><td style="text-align:center">decimal(20,2)</td><td style="text-align:center">商品价格保留两位小数，18整数位+2小数位</td></tr><tr><td style="text-align:center">stock</td><td style="text-align:center">int</td><td style="text-align:center">商品数量</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">int</td><td style="text-align:center">商品状态</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><ol><li>商品状态分为三种，在售、下架、删除。</li></ol><h4 id="购物车表（cart）"><a href="#购物车表（cart）" class="headerlink" title="购物车表（cart）"></a>购物车表（cart）</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">user_id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">product_id</td><td style="text-align:center">int</td><td style="text-align:center">商品id</td></tr><tr><td style="text-align:center">quantity</td><td style="text-align:center">int</td><td style="text-align:center">商品数量</td></tr><tr><td style="text-align:center">checked</td><td style="text-align:center">int</td><td style="text-align:center">是否选择</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><ol><li>checked商品是否被选择</li></ol><h4 id="支付信息表（pay-info）"><a href="#支付信息表（pay-info）" class="headerlink" title="支付信息表（pay_info）"></a>支付信息表（pay_info）</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">user_id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">order_no</td><td style="text-align:center">bigint</td><td style="text-align:center">订单号</td></tr><tr><td style="text-align:center">pay_platform</td><td style="text-align:center">int</td><td style="text-align:center">支付平台1.支付宝2.微信</td></tr><tr><td style="text-align:center">platform_number</td><td style="text-align:center">varchar</td><td style="text-align:center">支付宝支付流水号</td></tr><tr><td style="text-align:center">platform_status</td><td style="text-align:center">varchar</td><td style="text-align:center">支付宝支付状态</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><h4 id="订单表-order"><a href="#订单表-order" class="headerlink" title="订单表(order)"></a>订单表(order)</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">order_no</td><td style="text-align:center">bigint</td><td style="text-align:center">订单号</td></tr><tr><td style="text-align:center">user_id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">shipping_id</td><td style="text-align:center">int</td><td style="text-align:center">订单地址</td></tr><tr><td style="text-align:center">payment</td><td style="text-align:center">decimal(20,2)</td><td style="text-align:center">实际付款金额</td></tr><tr><td style="text-align:center">payment_type</td><td style="text-align:center">int</td><td style="text-align:center">支付类型</td></tr><tr><td style="text-align:center">postage</td><td style="text-align:center">int</td><td style="text-align:center">运费</td></tr><tr><td style="text-align:center">status</td><td style="text-align:center">int</td><td style="text-align:center">订单状态</td></tr><tr><td style="text-align:center">payment_time</td><td style="text-align:center">datetime</td><td style="text-align:center">支付时间</td></tr><tr><td style="text-align:center">spend_time</td><td style="text-align:center">datetime</td><td style="text-align:center">发货时间</td></tr><tr><td style="text-align:center">end_time</td><td style="text-align:center">datetime</td><td style="text-align:center">交易完成时间</td></tr><tr><td style="text-align:center">close_time</td><td style="text-align:center">datetime</td><td style="text-align:center">交易关闭时间</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><ol><li>订单号为唯一索引 </li></ol><h4 id="订单明细表-order-item"><a href="#订单明细表-order-item" class="headerlink" title="订单明细表(order_item)"></a>订单明细表(order_item)</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">order_no</td><td style="text-align:center">bigint</td><td style="text-align:center">订单号</td></tr><tr><td style="text-align:center">user_id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">product_id</td><td style="text-align:center">int</td><td style="text-align:center">商品id</td></tr><tr><td style="text-align:center">product_name</td><td style="text-align:center">varchar</td><td style="text-align:center">商品名称</td></tr><tr><td style="text-align:center">payment_image</td><td style="text-align:center">varchar</td><td style="text-align:center">商品图片地址</td></tr><tr><td style="text-align:center">current_unit_price</td><td style="text-align:center">decimal</td><td style="text-align:center">生成订单时的商品单价</td></tr><tr><td style="text-align:center">quantity</td><td style="text-align:center">int</td><td style="text-align:center">商品数量</td></tr><tr><td style="text-align:center">total_price</td><td style="text-align:center">decimal(20,2)</td><td style="text-align:center">商品总价</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><ol><li>bigint在java中为long类型</li></ol><h4 id="收货地址表-shipping"><a href="#收货地址表-shipping" class="headerlink" title="收货地址表(shipping)"></a>收货地址表(shipping)</h4><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">user_id</td><td style="text-align:center">int</td><td style="text-align:center">—</td></tr><tr><td style="text-align:center">product_id</td><td style="text-align:center">int</td><td style="text-align:center">商品id</td></tr><tr><td style="text-align:center">receiver_name</td><td style="text-align:center">varchar</td><td style="text-align:center">收货姓名</td></tr><tr><td style="text-align:center">receiver_zip</td><td style="text-align:center">varchar</td><td style="text-align:center">邮编</td></tr><tr><td style="text-align:center">receiver_phone</td><td style="text-align:center">varchar</td><td style="text-align:center">电话</td></tr><tr><td style="text-align:center">receiver_mobile</td><td style="text-align:center">varchar</td><td style="text-align:center">手机号</td></tr><tr><td style="text-align:center">receiver_province</td><td style="text-align:center">varchar</td><td style="text-align:center">省份</td></tr><tr><td style="text-align:center">receiver_city</td><td style="text-align:center">varchar</td><td style="text-align:center">城市</td></tr><tr><td style="text-align:center">receiver_district</td><td style="text-align:center">varchar</td><td style="text-align:center">区/县</td></tr><tr><td style="text-align:center">receiver_address</td><td style="text-align:center">varchar</td><td style="text-align:center">详细地址</td></tr><tr><td style="text-align:center">create_time</td><td style="text-align:center">datetime</td><td style="text-align:center">创建时间</td></tr><tr><td style="text-align:center">update_time</td><td style="text-align:center">datetime</td><td style="text-align:center">最后一次更新时间</td></tr></tbody></table><h2 id="项目构架设计"><a href="#项目构架设计" class="headerlink" title="项目构架设计"></a>项目构架设计</h2><ul><li>com.cmall<ul><li>common : 存放项目中的一些常量，拦截异常的公共类等</li><li>controller : 前端控制器层。</li><li>dao   : data accessobject 数据接口访问层。包含各种数据库操作方法。</li><li>pojo : 数据库交互的一些数据</li><li>service : 数据服务接口层。</li><li>util : 工具类库。</li><li>vo : value object/view object。视图包装对象，用于封装客户端请求的数据，防止部分数据泄露，保证数据安全。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;电商平台&quot;&gt;&lt;a href=&quot;#电商平台&quot; class=&quot;headerlink&quot; title=&quot;电商平台&quot;&gt;&lt;/a&gt;电商平台&lt;/h1&gt;&lt;p&gt;学习了很久的java，说的算完整的项目也就是一个博客项目。第四年打算做一个电商项目练习一下学习成果。&lt;/p&gt;
&lt;h2 id=
      
    
    </summary>
    
      <category term="Java项目" scheme="https://04071011.xyz/categories/Java%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构题 - 数据结构 - 2020</title>
    <link href="https://04071011.xyz/2020/12/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%A2%98/"/>
    <id>https://04071011.xyz/2020/12/10/数据结构题/</id>
    <published>2020-12-10T09:37:29.000Z</published>
    <updated>2020-12-30T12:43:28.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java数据结构题集"><a href="#Java数据结构题集" class="headerlink" title="Java数据结构题集"></a>Java数据结构题集</h1><h2 id="2020-9-30-单链表：从尾到头打印单链表（百度面试）"><a href="#2020-9-30-单链表：从尾到头打印单链表（百度面试）" class="headerlink" title="(2020.9.30)单链表：从尾到头打印单链表（百度面试）"></a>(2020.9.30)单链表：从尾到头打印单链表（百度面试）</h2><ol><li>思路：<ul><li>自己：使用递归实现，遍历单链表，如果没有到末尾，则继续往下找，找到最后一个后打印输出，接着返回上一层继续输出。</li><li>尚硅谷：使用Stack栈类实现。</li></ul></li><li>实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从尾到头输出单链表（Stack类）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//空链表，不能打印</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建一个栈，将各个节点压入栈中</span></span><br><span class="line">    Stack&lt;HeroNode&gt; stack = <span class="keyword">new</span> Stack&lt;HeroNode&gt;();</span><br><span class="line">    HeroNode cur = head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(cur);</span><br><span class="line">        cur = cur.next;     <span class="comment">//cur后移，压入下一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印输出栈中的节点</span></span><br><span class="line">    <span class="keyword">while</span> (stack.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        System.out.println(stack.pop());    <span class="comment">//栈的特点是先进后出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Josephu-约瑟夫、约瑟夫环-问题："><a href="#Josephu-约瑟夫、约瑟夫环-问题：" class="headerlink" title="Josephu(约瑟夫、约瑟夫环)问题："></a>Josephu(约瑟夫、约瑟夫环)问题：</h2><p>设编号为1,2, …n的n个人围坐一圈，约定编号为k(1&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出列编号的序列。</p><ol><li>思路：<ul><li>尚硅谷：构建一个单向的环形链表。先创建一个辅助(指针)变量，事先指向环形链表最后一个节点。当小孩报数时，让first和helper指针同时移动m-1次。first指向的小孩出圈就是让helper指向小孩的下一个节点。原来的first指向的节点没有引用就会变回收。</li></ul></li><li>实现:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 根据用户输入，计算出小孩出圈的顺序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> startNo : 表示从第几个小孩开始数数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> countNum : 表示数几下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> nums : 表示最初有多少小孩在圈内</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNo,<span class="keyword">int</span> countNum,<span class="keyword">int</span> nums)</span></span>&#123;</span><br><span class="line">    <span class="comment">//先对数据进行校验</span></span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNo &lt; <span class="number">1</span> || startNo &gt; nums) &#123;</span><br><span class="line">        System.out.println(<span class="string">"参数输入有误，请重新输入"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建要给辅助指针，帮助完成小孩出圈</span></span><br><span class="line">    Boy helper = first;</span><br><span class="line">    <span class="comment">//需求创建一个辅助指针(变量)helper,事先应该指向环形链表的最后这个节点</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (helper.getNext()==first)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小孩报数前，先让first和helper移动k-1次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; startNo-<span class="number">1</span>; j++) &#123;</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper = helper.getNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出圈 让first 和 helper同时移动m-1次</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (helper == first)<span class="keyword">break</span>;  <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//同时移动countNum-1，数数ing</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//出圈</span></span><br><span class="line">        System.out.printf(<span class="string">"小孩%d出圈\n"</span>,first.getNo());</span><br><span class="line">        first = first.getNext();</span><br><span class="line">        helper.setNext(first);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"最后留在圈中的小孩编号为"</span>+helper.getNo());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java数据结构题集&quot;&gt;&lt;a href=&quot;#Java数据结构题集&quot; class=&quot;headerlink&quot; title=&quot;Java数据结构题集&quot;&gt;&lt;/a&gt;Java数据结构题集&lt;/h1&gt;&lt;h2 id=&quot;2020-9-30-单链表：从尾到头打印单链表（百度面试）&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="数据结构" scheme="https://04071011.xyz/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>2020.12.8</title>
    <link href="https://04071011.xyz/2020/12/08/2020-12-8/"/>
    <id>https://04071011.xyz/2020/12/08/2020-12-8/</id>
    <published>2020-12-08T09:27:32.000Z</published>
    <updated>2020-12-30T12:43:28.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="Thread中常用方法"><a href="#Thread中常用方法" class="headerlink" title="Thread中常用方法"></a>Thread中常用方法</h3><ol><li>start()  启动当前线程：调用线程的run方法</li><li>run()    通常需要重写Thread类中的此方法，将创建线程需要做的操作声明在此方法中</li><li>currentThread()  静态方法，返回执行当前代码的线程</li><li>getName()    获取当前线程的名字</li><li>setName()    创建当前线程的名字</li><li>yield()  释放当前cpu的控制权</li><li>join()   在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行后，线程a才结束阻塞状态</li><li>stop()   此方法已过时，调用此方法，强制结束当前线程<h3 id="线程的调度"><a href="#线程的调度" class="headerlink" title="线程的调度"></a>线程的调度</h3></li></ol><ul><li>调度策略<ul><li>时间片</li><li>抢占式：高优先级的线程抢占cpu</li></ul></li><li>Java的调度方法<ul><li>同优先级线程组先进先出队列（先到先服务），使用时间片策略</li><li>对高优先级，使用优先调度的抢占式策略<h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3></li></ul></li><li>MAX_PRIORITY:10</li><li>MIN_PRIORITY:1</li><li>NORM_PRIORITY:5   默认线程优先级为5<h3 id="涉及的方法"><a href="#涉及的方法" class="headerlink" title="涉及的方法"></a>涉及的方法</h3></li><li>getPriority():返回的线程优先值</li><li>getPriority(int new Priority):改变线程的优先级</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.11.5</title>
    <link href="https://04071011.xyz/2020/11/05/2020-11-5/"/>
    <id>https://04071011.xyz/2020/11/05/2020-11-5/</id>
    <published>2020-11-05T09:07:47.000Z</published>
    <updated>2020-12-30T12:43:28.513Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="手动抛出异常"><a href="#手动抛出异常" class="headerlink" title="手动抛出异常"></a>手动抛出异常</h3><p>throw new xxx(“”);</p><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><ol><li>需要继承现有的异常类</li><li>提供全局常量：serialVersionUID</li><li>提供重载的构造器</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.11.3</title>
    <link href="https://04071011.xyz/2020/11/03/2020-11-3/"/>
    <id>https://04071011.xyz/2020/11/03/2020-11-3/</id>
    <published>2020-11-03T09:23:47.000Z</published>
    <updated>2020-12-30T12:43:28.514Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="throws-异常类型"><a href="#throws-异常类型" class="headerlink" title="throws + 异常类型"></a>throws + 异常类型</h3><ol><li>“throws + 异常类型”写在方法声明处。指明此方法执行时，可能会抛出的异常类型。一旦方法体执行时，出现异常，仍然会在异常代码处生成一个异常对象。此对象满足throws异常类型时，就会被抛出。<h3 id="如何选择try-catch-finally还是throws"><a href="#如何选择try-catch-finally还是throws" class="headerlink" title="如何选择try-catch-finally还是throws"></a>如何选择try-catch-finally还是throws</h3></li><li>如果父类被重写的方法没有throws方式处理异常，则子类重写的方法不能使用throws，意味着如果子类重写的方法中有异常，则必须使用try-catch-finally方式处理。</li><li>执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。那么建议使用throws的方式进行集中处理。而执行的方法可以考虑使用try-catch-finally方式处理异常。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.11.2</title>
    <link href="https://04071011.xyz/2020/11/02/2020-11-2/"/>
    <id>https://04071011.xyz/2020/11/02/2020-11-2/</id>
    <published>2020-11-02T08:39:07.000Z</published>
    <updated>2020-12-30T12:43:28.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常的处理：抓抛模型"><a href="#异常的处理：抓抛模型" class="headerlink" title="异常的处理：抓抛模型"></a>异常的处理：抓抛模型</h3><ul><li>过程一：”抛”：程序在正常执行过程中，出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出，后面代码不执行。</li><li>过程二：”抓”：可以理解为异常的处理方式。①try-catch-finally ②throws<h3 id="try-catch-finally的使用"><a href="#try-catch-finally的使用" class="headerlink" title="try-catch-finally的使用"></a>try-catch-finally的使用</h3>···Java<br>try{<br>  //可能出现的异常代码<br>}catch(异常类型1 变量名1){<br>  //处理异常的方法1<br>}catch(异常类型2 变量名2){<br>  //处理异常的方法2<br>}catch(异常类型3 变量名3){<br>  //处理异常的方法3<br>}<br>…..<br>finally{<br>  //一定会执行的代码<br>}<br>···</li></ul><ol><li>finally是可选的。</li><li>使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。</li><li>一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常处理。一旦处理完成，就跳出当前的try-catch结构(在没有写finally的情况)。</li><li>catch中异常类型，如果没有子父类关系，谁先谁后无所谓。如果满足，则子类一定声明在父类上方，否则报错。</li><li>常用异常对象处理方式：①String getMessage(); ②printStackTrace();</li><li>finally中声明的是一定会执行的代码。即使catch中出现了异常，try、catch中有return语句。</li><li>像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要手动释放资源。此时就需要声明在finally中。</li><li>try-catch-finally结构可以嵌套。</li></ol><p>###</p><ol><li>使用try-catch-finally处理编译时异常，使得程序在编译时不在报错，但运行实施可能还会报错。相当于我们将一个编译时可能出现的异常延迟到运行时出现。</li><li>开发中，由于运行时异常比较常见，所以我们通常不针对运行时异常编写try-catch-finally了。正对编译时异常，我们一定要考虑异常的处理。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.29</title>
    <link href="https://04071011.xyz/2020/10/29/2020-10-29/"/>
    <id>https://04071011.xyz/2020/10/29/2020-10-29/</id>
    <published>2020-10-29T08:37:32.000Z</published>
    <updated>2020-12-30T12:43:28.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ol><li>Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError(栈溢出)和OOM(堆溢出)。</li><li>一般不编写针对性的代码。<h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3></li><li>其它因为编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。<h3 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h3></li></ol><ul><li>java.lang.Throwable<ul><li>java.lang.Error:一般不编写针对性代码进行处理</li><li>java.lang.Exception:可以进行异常的处理<ul><li>编译时异常(受检checked异常)<ul><li>IOException<ul><li>FileNotFoundException</li></ul></li><li>ClassNotFoundException</li></ul></li><li>运行时异常(非受检unchecked异常)<ul><li>NullPointerException</li><li>ArrayIndexOutOfBoundsException</li><li>ClassCastException</li><li>NumberFormatException</li><li>InputMismatchException</li><li>ArithmeticException</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.26</title>
    <link href="https://04071011.xyz/2020/10/26/2020-10-26/"/>
    <id>https://04071011.xyz/2020/10/26/2020-10-26/</id>
    <published>2020-10-26T08:01:27.000Z</published>
    <updated>2020-12-30T12:43:28.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol><li>Java中允许将一个类A声明在一个类B中，则类A就是内部类</li><li>内部类的分类：<ul><li>成员内部类：静态、非静态</li><li>局部内部类：方法内、代码块内、构造器内</li><li>匿名内部类</li><li>静态内部类</li></ul></li><li>成员内部类：一方面作为外部类的成员，一方面作为一个类。</li><li>内部类调用外部类的属性时，可以使用外部类.this.xxx的方式调用。 </li></ol><ul><li>为什么要使用内部类？</li></ul><ol><li>每个内部类都能独立的继承一个接口的实现，无论外部类是否继承了某个(接口的)实现。内部类使多继承的解决方案变得完整。</li><li>方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</li><li>方便编写事件驱动程序。</li><li>方便编写线程代码。</li></ol><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><h4 id="实例化成员内部类的对象"><a href="#实例化成员内部类的对象" class="headerlink" title="实例化成员内部类的对象"></a>实例化成员内部类的对象</h4><ol><li>静态的成员内部类<ul><li>外部类.成员内部类 xx = new 外部类.成员内部类();</li></ul></li><li>（非静态的成员内部类）<ul><li>先实例化一个外部类的对象</li><li>外部类.内部类 xxx = 外部类对象.new 成员内部类();</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内部
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.22</title>
    <link href="https://04071011.xyz/2020/10/22/2020-10-22/"/>
    <id>https://04071011.xyz/2020/10/22/2020-10-22/</id>
    <published>2020-10-22T08:15:32.000Z</published>
    <updated>2020-12-30T12:43:28.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="逆波兰计算器"><a href="#逆波兰计算器" class="headerlink" title="逆波兰计算器"></a>逆波兰计算器</h3><p>输入一个逆波兰表达式(后缀表达式)，使用栈(Stack)，计算其结果，支持小括号和多位整数。<br>将中缀表达式转成后缀表达式的思路：</p><ol><li>先设定两个栈，s1和s2。s1为运算符栈，s2为储存中间结果的栈。</li><li>从左至右扫描中缀表达式。</li><li>如果遇到操作数则压入s2中。</li><li>如果遇到操作符，比较其与s1栈顶的运算符优先级。<ul><li>如果s1位空或栈顶运算符位左括号“（”，则直接将此运算符入栈；</li><li>否则如果当前操作符的优先级比s1栈顶的优先级高，则直接入栈；</li><li>否则，将s1栈顶的运算符弹出压入到s2中，再次转到 4.1 与s1中的新栈顶运算符比较。</li></ul></li><li>遇到括号时：<ul><li>如果为左括号“（”，则直接压入s1；</li><li>如果遇到右括号“）”，则依次弹出s1中栈顶的运算符，放入s2中，直到遇到左括号为止，此时这一对括号丢弃。</li></ul></li><li>重复步骤2至5，直到表达式最右边。</li><li>将s1中剩余的运算符依次弹出并压入s2中。</li><li>依次弹出s2中元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&quot;栈&quot;&gt;&lt;a href=&quot;#栈&quot; class=&quot;headerlink&quot; title=&quot;栈&quot;&gt;&lt;/a&gt;栈&lt;/h2&gt;&lt;h
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.20</title>
    <link href="https://04071011.xyz/2020/10/20/2020-10-20/"/>
    <id>https://04071011.xyz/2020/10/20/2020-10-20/</id>
    <published>2020-10-20T08:11:52.000Z</published>
    <updated>2020-12-30T12:43:28.509Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="栈-stack"><a href="#栈-stack" class="headerlink" title="栈(stack)"></a>栈(stack)</h2><ol><li>栈是一个先入后出的有序列表</li><li>栈是限制线性表中元素的拆入和删除只能在线性表的同一端进行的一种特殊的线性表。允许插入和删除的一端为栈顶(Top),固定的一端，为栈底(Bottom)。</li><li>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶。删除时，最先放入的元素最后删除，最后放入的元素最先删除。<h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3></li><li>子程序的调用</li><li>处理递归调用</li><li>表达式的转换与求值</li><li>二叉树的遍历</li><li>图形的深度优先搜索法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h2 id=&quot;栈-stack&quot;&gt;&lt;a href=&quot;#栈-stack&quot; class=&quot;headerlink&quot; title=&quot;栈(s
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.19</title>
    <link href="https://04071011.xyz/2020/10/19/2020-10-19/"/>
    <id>https://04071011.xyz/2020/10/19/2020-10-19/</id>
    <published>2020-10-19T08:06:02.000Z</published>
    <updated>2020-12-30T12:43:28.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="接口-implements"><a href="#接口-implements" class="headerlink" title="接口 implements"></a>接口 implements</h2><ol><li>开发中可使用四种方法传参，当形参为接口时。</li></ol><ul><li>传入接口的非匿名实现类的非匿名对象。</li><li>传入接口的非匿名实现类的匿名对象。</li><li>传入接口的匿名实现类的非匿名对象。</li><li>传入接口的匿名实现类的匿名对象。</li></ul><ol start="2"><li>在子类(或实现类)的方法中调用父类、接口中被重写的方法</li></ol><ul><li>调用自己定义重写的方法(方法体();)</li><li>调用父类中的声明的方法(super.方法体();)</li><li>调用接口中默认方法(接口.super.方法体();)<h3 id="接口的应用"><a href="#接口的应用" class="headerlink" title="接口的应用"></a>接口的应用</h3></li></ul><ol><li>代理模式(Proxy)<br> 代理模式是Java开发中使用最多的设计模式。代理模式就是为其他对象提供一种代理以控制对这个对象的访问。<ul><li>应用场景 <ul><li>安全代理：屏蔽对真实角色的直接访问</li><li>远程代理：通过代理类处理远程方法调用(RMI)</li><li>延迟加载：先加载轻量级的代理对象，真正需要在加载真实对象。</li></ul></li><li>分类<ul><li>静态代理(静态定义代理类)</li><li>动态代理(动态生成代理类) </li></ul></li></ul></li><li>工厂模式<br> 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。<br> 就是创建对象的。<ul><li>设计原则<ul><li>OCP(开闭原则，Open-Closed Principle)</li><li>DIP(依赖倒转原则，Dependence Inversion Principle)</li><li>LOD(迪米特法则，Law Of Demeter)</li></ul></li><li>分类<ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;接口-implements&quot;&gt;&lt;a href=&quot;#接口-implements&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.12</title>
    <link href="https://04071011.xyz/2020/10/12/2020-10-12/"/>
    <id>https://04071011.xyz/2020/10/12/2020-10-12/</id>
    <published>2020-10-12T08:33:02.000Z</published>
    <updated>2020-12-30T12:43:28.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="模板方法设计模式-TemplateMethod"><a href="#模板方法设计模式-TemplateMethod" class="headerlink" title="模板方法设计模式(TemplateMethod)"></a>模板方法设计模式(TemplateMethod)</h2><p>抽象类体现的就是一种模板模式的设计。抽象类作为多个子类的通用模板，子类在抽象类的基础上扩展、改造，但总体上会保留抽象类的行为方式。  </p><h3 id="模板方法设计要求"><a href="#模板方法设计要求" class="headerlink" title="模板方法设计要求"></a>模板方法设计要求</h3><p>软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但某些易变的部分可以抽象出来，让不同的子类实现。</p><h2 id="Calendar类"><a href="#Calendar类" class="headerlink" title="Calendar类"></a>Calendar类</h2><p>可以获取当前日期。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line"><span class="keyword">int</span> mouth = calendar.get(Calendar.MONTH);   <span class="comment">//获取当前月份</span></span><br></pre></td></tr></table></figure></p><h2 id="接口-implements"><a href="#接口-implements" class="headerlink" title="接口 implements"></a>接口 implements</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">XX</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>JAVA不支持多继承，有了接口就可以得到多继承的效果</li><li>接口和类是并列的结构</li><li>JDK7及以前：只能定义全局常量和抽象方法<ul><li>全局常量：public static final的(书写时可以省略)</li><li>抽象方法：public abstract的</li></ul></li><li>JDK8：除了全局常量和抽象方法外，还可以定义静态方法和默认方法</li><li>接口中无法定义构造器，意味着接口无法实例化</li><li>实现类覆盖了接口中的所有抽象方法，则此实现类可以实例化</li><li>如果实现类没有覆盖接口中的所有抽象方法，则此类仍为一个抽象类 </li><li>如果实现类需要继承父类，则先写继承后写接口</li><li>接口与接口之间是多继承的</li><li>接口实际就是定义了一种规范</li><li>接口也满足多态性</li><li>接口中定义的静态方法，只能通过接口来调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;模板方法设计模式-TemplateMethod&quot;&gt;&lt;a href=&quot;#模板方法设计模式-TemplateMetho
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.10</title>
    <link href="https://04071011.xyz/2020/10/10/2020-10-10/"/>
    <id>https://04071011.xyz/2020/10/10/2020-10-10/</id>
    <published>2020-10-10T08:02:12.000Z</published>
    <updated>2020-12-30T12:43:28.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="final-关键字"><a href="#final-关键字" class="headerlink" title="final 关键字"></a>final 关键字</h2><ol><li>可以用来修饰方法、类、属性</li><li>被final修饰的类无法被继承，被final修饰的方法无法被重写，被final修饰的属性的值无法被修改（即为常量）</li><li>final修饰的属性可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</li><li>static final 用来修饰属性：全局常量，修饰方法：无法被重写的静态方法</li></ol><h2 id="abstract关键字"><a href="#abstract关键字" class="headerlink" title="abstract关键字"></a>abstract关键字</h2><ol><li>不能修饰属性、构造器等结构</li><li>不能修饰私有方法、静态方法、final的方法、final的类<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3></li><li>abstract修饰的类不能实例化</li><li>抽象类中一定有构造器，便于子类实例化时调用</li><li>开发中都会提供抽象类的子类，让子类对象实例化，完成相关操作<h4 id="抽象类的匿名子类"><a href="#抽象类的匿名子类" class="headerlink" title="抽象类的匿名子类"></a>抽象类的匿名子类</h4>设Pe为抽象类，创建一个Pe的匿名子类。<br>抽象类是无法实例化的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Pe pe = <span class="keyword">new</span> Pe()&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><ol><li>抽象方法没有方法体，只有声明</li><li>有抽象方法的类一定是抽象类，抽象类中不一定有抽象方法</li><li>若子类重写了父类中的抽象方法，子类可以实例化</li><li>子类中没有重写父类中所有的抽象方法，则子类还是个抽象类</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;final-关键字&quot;&gt;&lt;a href=&quot;#final-关键字&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.10.9</title>
    <link href="https://04071011.xyz/2020/10/09/2020-10-9/"/>
    <id>https://04071011.xyz/2020/10/09/2020-10-9/</id>
    <published>2020-10-09T09:02:12.000Z</published>
    <updated>2020-12-30T12:43:28.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="static修饰方法：静态方法"><a href="#static修饰方法：静态方法" class="headerlink" title="static修饰方法：静态方法"></a>static修饰方法：静态方法</h3><ol><li>随着类的加载而加载，可以通过“类.静态方法”的形式调用</li><li>静态方法中只能调用静态的方法或属性<br>非静态的方法中，既可以调用非静态的属性也可以调用静态的属性（因为静态与非静态的生命周期不同）<h3 id="static注意点："><a href="#static注意点：" class="headerlink" title="static注意点："></a>static注意点：</h3>在静态的方法中，不能使用this、super关键字  </li></ol><ul><li><p>开发中如何确定一个属性是否声明为static？</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性可以被多个对象共享，不会随着对象的不同而不同</span><br></pre></td></tr></table></figure></li><li><p>开发中如何确定一个方法是否声明为static？</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 操作静态属性的方法通常设置为static</span><br><span class="line">2. 工具类中的方法，习惯上声明为static的</span><br></pre></td></tr></table></figure></li></ul><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。<br>设计模式一共有23种：</p><ul><li>创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li><li>结构型模式（7种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li><li>行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式<h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3>采用一定的方法在整个软件系统中，对某个类只能存在一个对象实例，且该类只提供一个取得其对象实力的方法。<h4 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h4></li></ul><ol><li>私有化类的构造器</li><li>内部创建类的（静态）对象</li><li>提供公共（静态）的方法，返回类的对象<h4 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h4></li><li>私有化类的构造器</li><li>声明当前类（静态）对象，没有初始化。</li><li>声明公共静态的方法，在方法内部判断当前声明对象是否为空，为空初始化类对象，返回当前类的对象<h4 id="区分-饿汉式-和-懒汉式"><a href="#区分-饿汉式-和-懒汉式" class="headerlink" title="区分 饿汉式 和 懒汉式"></a>区分 饿汉式 和 懒汉式</h4>|名称|缺点|优点|<br>|:—:|:—|:—|<br>|饿汉式|对象加载时间过长|是线程安全的|<br>|懒汉式|没使用多线程写法时是线程不安全的|延迟对象的创建|<h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4>由于单例设计模式只产生一个实例，减少了系统性能开销<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4></li></ol><ul><li>网站计数器  </li><li>应用程序的日志应用  </li><li>数据库连接池  </li><li>读取配置文件的类  </li><li>Application  </li><li>Windows 的任务管理器  </li><li>Windows 的回收站  </li></ul><h2 id="main-方法"><a href="#main-方法" class="headerlink" title="main()方法"></a>main()方法</h2><ol><li>程序的入口</li><li>是一个普通的静态的方法</li><li>main()方法的参数可以作为与控制台交互的一种方法</li></ol><h2 id="代码块-初始化块"><a href="#代码块-初始化块" class="headerlink" title="代码块(初始化块)"></a>代码块(初始化块)</h2><ol><li>用来初始化类、对象</li><li>只能使用 static 修饰</li><li>static代码块随着类的加载而执行，而且只执行一次</li><li>非static代码块随着对象的创建而执行</li><li>非static代码块可以在创建对象时，对对象的属性进行初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xxx</span></span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//我是一个代码块</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//我是一个静态的代码块</span></span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表缺点：无法自我删除，查找只能是一个方向。<br>双向链表优点：可以向前或向后查找、可以自我删除。<br>单向链表vs双向链表不同点：添加、修改、删除不同外基本一致</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;static&quot;&gt;&lt;a href=&quot;#static&quot; class=&quot;headerlink&quot; title=&quot;stati
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.9.30</title>
    <link href="https://04071011.xyz/2020/09/30/2020-9-30/"/>
    <id>https://04071011.xyz/2020/09/30/2020-9-30/</id>
    <published>2020-09-30T09:17:22.000Z</published>
    <updated>2020-12-30T12:43:28.522Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><p>内存中，栈主要存放局部变量、堆主要存放new出来的结构（对象、数组），方法区主要存放类的加载信息、静态域、常量池。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;内存&quot;&gt;&lt;a href=&quot;#内存&quot; class=&quot;headerlink&quot; title=&quot;内存&quot;&gt;&lt;/a&gt;内存&lt;/h
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.9.29</title>
    <link href="https://04071011.xyz/2020/09/29/2020-9-29/"/>
    <id>https://04071011.xyz/2020/09/29/2020-9-29/</id>
    <published>2020-09-29T09:16:32.000Z</published>
    <updated>2020-12-30T12:43:28.519Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><p>可以用来修饰：属性、方法、代码块、内部类<br>使用static修饰的属性：静态变量（类变量）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">属性:按是否使用static修饰，分为：静态属性 vs 非静态属性(实例变量)  </span><br><span class="line">实例变量：创建类的多个对象，每个对象都独立的拥有一套类中非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值修改  </span><br><span class="line">静态变量：创建类的多个对象，多个对象共享同一个静态变量。当修改某一个对象中的静态变量时，其他的对象中的静态变量也会修改。</span><br><span class="line">其他说明：</span><br><span class="line">   1. 静态变量随着类的加载而加载，可以通过“类.静态变量”的方式调用</span><br><span class="line">   2. 静态变量的加载要早于对象</span><br><span class="line">   3. 类只会加载一次，则静态变量在内存中也只存在一份，存在方法的静态域</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Java&quot;&gt;&lt;a href=&quot;#Java&quot; class=&quot;headerlink&quot; title=&quot;Java&quot;&gt;&lt;/a&gt;Java&lt;/h1&gt;&lt;h2 id=&quot;static关键字&quot;&gt;&lt;a href=&quot;#static关键字&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.9.27</title>
    <link href="https://04071011.xyz/2020/09/27/2020-9-27/"/>
    <id>https://04071011.xyz/2020/09/27/2020-9-27/</id>
    <published>2020-09-27T09:15:22.000Z</published>
    <updated>2020-12-30T12:43:28.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h2><p>含义：一个事物的多种形态<br>在Java中，父类的引用可以指向子类的对象，通过此引用调用的方法为子类重写的方法（没有重写的也可以，但那就没必要了）<br>使用：虚拟方法调用，编译看左边，运行看右边。当父类中不存在子类中有的方法时，无法调用。属性的调用还是父类的属性。<br>使用前提：1. 类的继承性 2. 方法重写  </p><h3 id="虚拟方法调用"><a href="#虚拟方法调用" class="headerlink" title="虚拟方法调用"></a>虚拟方法调用</h3><p>定义：子类中定义了与父类同名同参数的方法，在多态的情况下，此时父类的方法叫虚拟方法。父类根据赋给它不同的子类对象，动态调用属于子类的该方法。在编译期无法确定实际调用的方法。    </p><h2 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h2><p>子类的引用指向父类，父类使用强制类型转换符。<br>可能出现ClassCastException的异常。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>使用：a instanceof A<br>判断对象a是否是类A的实例，如果是返回true。为了避免出现异常。</p><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><p>所有Java类的根父类。一个类如果没有使用extends关键字指明其父类，则默认为java.lang.Object类。  </p><h3 id="主要结构"><a href="#主要结构" class="headerlink" title="主要结构"></a>主要结构</h3><table><thead><tr><th style="text-align:center">序号</th><th>方法名</th><th style="text-align:center">类型</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"></td></tr></tbody></table><p>1|public Object()|构造|构造器<br>2|public boolean equals(Qbject obj)|普通|对象比较<br>3|public int hashCode()|普通|取得Hash码<br>4|public String toString()|普通|对象打印时调用<br>v</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="== 运算符"></a>== 运算符</h2><ol><li>可以使用在基本数据类型变量和引用数据类型变量中</li><li>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（不一定类型相等）。</li><li>如果比较的是引用类型变量：比较两个对象地址值是否相同，即两个引用是否指向同一个对象实体。<h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals()方法"></a>equals()方法</h2></li><li>只适用于引用数据类型</li><li>Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同</li><li>像String、Date、File、包装类等都重写了Object类的equals()方法，比较的是两个对象的实体内容是否相同。</li><li>通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象‘实体内容’是否相同，我们需要对此方法进行重写。  <h3 id="重写equals-方法的原则"><a href="#重写equals-方法的原则" class="headerlink" title="重写equals()方法的原则"></a>重写equals()方法的原则</h3>对称性、自反性、传递性、一致性</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;多态性&quot;&gt;&lt;a href=&quot;#多态性&quot; class=&quot;headerlink&quot; title=&quot;多态性&quot;&gt;&lt;/a&gt;多态
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.9.22</title>
    <link href="https://04071011.xyz/2020/09/22/2020-9-22/"/>
    <id>https://04071011.xyz/2020/09/22/2020-9-22/</id>
    <published>2020-09-22T09:05:25.000Z</published>
    <updated>2020-12-30T12:43:28.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>如果我们没有显式声明一个类的父类，则此类继承于java.lang.Object类。所有的java类(除java.lang.Object类之外)，都直接或间接继承于java.lang.Object类。</p><h2 id="重写-override-overwrite"><a href="#重写-override-overwrite" class="headerlink" title="重写(override / overwrite)"></a>重写(override / overwrite)</h2><ol><li>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</li><li>应用：重写以后，当创建子类对象以后，通过子类v对象调用子父类中的同名同参数的方法时，执行的时子类从写父类的方法。</li><li><p>重写的规定：</p><blockquote><p>方法的声明：<br> 权限修饰修饰符 返回值类型 方法名(形参列表) throws 异常的类型{  </p><pre><code>//方法体  }  </code></pre><p> 约定俗成：子类中的叫重写的方法，父类中叫被重写的方法</p><ol><li>子类重写的方法的方法名和形参列表与父类中被重写的方法相同</li><li>子类中重写的方法的权限修饰符，不小于父类中被重写的方法的权限修饰符  <ul><li>特殊情况：子类不能重写父类中声明为private权限的方法</li></ul></li><li>返回值类型：</li></ol><ul><li>父类被重写的方法返回值类型为void的，重写的方法也必须是void</li><li>父类被重写的方法的返回值为A类型，则重写的方法的返回值可以是A类或A类的子类</li><li>父类被重写的方法的返回值是基本数据类型，则重写方法也必须是相同的数据类型</li></ul><ol start="4"><li>子类重写的方法抛出的异常不大于父类被重写方法的异常类型  </li></ol></blockquote><p> 子类和父类中同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static（不是重写）</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;Object&quot;&gt;&lt;a href=&quot;#Object&quot; class=&quot;headerlink&quot; title=&quot;Objec
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.9.21</title>
    <link href="https://04071011.xyz/2020/09/21/2020-9-21/"/>
    <id>https://04071011.xyz/2020/09/21/2020-9-21/</id>
    <published>2020-09-21T08:39:05.000Z</published>
    <updated>2020-12-30T12:43:28.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p>MVC是常用的设计模式之一，将程序分为三层，降低程序耦合性。 </p><blockquote><p>M 是 数据模型层 Model<br>V 是 视图模型层 View<br>C 是 控制器层 Controller</p></blockquote><h3 id="model层-主要处理数据："><a href="#model层-主要处理数据：" class="headerlink" title="model层 主要处理数据："></a>model层 主要处理数据：</h3><blockquote><p>数据对象封装 model.bean/domain<br>数据库操作对象 model.dao<br>数据库 model.db</p></blockquote><h3 id="controller层-处理业务逻辑："><a href="#controller层-处理业务逻辑：" class="headerlink" title="controller层 处理业务逻辑："></a>controller层 处理业务逻辑：</h3><blockquote><p>应用界面相关 controller.activity<br>存放fragment controller.fragment<br>显示列表的适配器 controller.adapter<br>服务相关 controller.service<br>抽取的基类 controller.base</p></blockquote><h3 id="view层-显示数据："><a href="#view层-显示数据：" class="headerlink" title="view层 显示数据："></a>view层 显示数据：</h3><blockquote><p>相关工具类 view.utils<br>自定义view view.ui</p></blockquote><h2 id="import-关键字"><a href="#import-关键字" class="headerlink" title="import 关键字"></a>import 关键字</h2><p>import:导入</p><ol><li>在源文件中显式的使用import结构导入指定包下的类、接口</li><li>import的声明在包的声明和类的声明之间</li><li>如果需要导入多个结构，并列写出</li><li>可以使用“xxx.*”的方式，导入xxx包下所有的结构</li><li>如果使用的类或接口是java.lang包下定义，可以不用导入</li><li>如果使用的类或接口是本包下定义的，可以省略import结构 </li><li>如果碰到两个重名的类，有一个需要使用全类名方式显示</li><li>使用“xxx.*”方式调用xxx包下所有所有的结构，但是xxx包下的子包，仍需要显式导入</li><li>import static:导入指定类或接口中静态的结构v</li></ol><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="一、继承的好处："><a href="#一、继承的好处：" class="headerlink" title="一、继承的好处："></a>一、继承的好处：</h3><ol><li>减少了代码冗余，提高了代码的复用性</li><li>便于功能的扩展</li><li>为了之后多态性的使用，提供了前提<h3 id="二、继承的格式"><a href="#二、继承的格式" class="headerlink" title="二、继承的格式"></a>二、继承的格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class A extends B&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>A:子类、派生类，subclass<br>B:父类、基类，superclass  </p><ol><li>体现：一旦子类A继承父类B以后，子类A就获取了父类B中声明的结构、属性、方法。<br>父类中声明为private的属性或方法，子类继承父类以后，仍然获取了父类中的私有结构。只因为有封装性的影响，使得子类不能直接调用父类的结构。</li><li>子类继承父类以后，还可以声明自己特有的属性或方法，实现功能扩展。子类和父类的关系，不同于子集和集合的关系。<h3 id="三、关于继承的规定"><a href="#三、关于继承的规定" class="headerlink" title="三、关于继承的规定"></a>三、关于继承的规定</h3></li><li>一个类可以被多个子类继承</li><li>一个子类不允许有多个父类，这是Java的单继承性</li><li>子父类是相对的概念</li><li>子类继承父类，就获取了直接父类和所有间接父类中声明的属性和方法</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;h2 id=&quot;MVC设计模式&quot;&gt;&lt;a href=&quot;#MVC设计模式&quot; class=&quot;headerlink&quot; title=&quot;MVC
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
  <entry>
    <title>2020.9.18</title>
    <link href="https://04071011.xyz/2020/09/18/2020-9-18/"/>
    <id>https://04071011.xyz/2020/09/18/2020-9-18/</id>
    <published>2020-09-18T08:35:15.000Z</published>
    <updated>2020-12-30T12:43:28.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><ul><li>what？：压缩数组的一种方式。  </li><li>why？：原数组中有大量重复无意义的数据，为了解决内存空间浪费的问题，所以使用稀疏数组压缩原数组，节省内存空间。  </li><li><p>how？：<br>  数组的第一列存放原数组的行数，第二列存放原数组的列数，第三列存放原数组对应行列中存放的值。<br>  二维数组 转 稀疏数组</p><blockquote><p>1.遍历原始的二维数组，得到有效数据的个数sum<br>2.根据sum就可以创建稀疏数组spareArr int[sum+1][3]<br>3.将二维数组的有效数据存入到稀疏数组</p></blockquote><p>  稀疏数组转原始二维数组</p><blockquote><p>1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组<br>2.读取第一行以后的数据，存入到二维数组中即可</p></blockquote><h6 id="思路根据尚硅谷的课程学习而来"><a href="#思路根据尚硅谷的课程学习而来" class="headerlink" title="思路根据尚硅谷的课程学习而来"></a>思路根据尚硅谷的课程学习而来</h6></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h1&gt;&lt;h2 id=&quot;稀疏数组&quot;&gt;&lt;a href=&quot;#稀疏数组&quot; class=&quot;headerlink&quot; title=&quot;稀疏数组&quot;&gt;&lt;/a&gt;稀疏数组&lt;/h
      
    
    </summary>
    
      <category term="日常记录" scheme="https://04071011.xyz/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="日常记录" scheme="https://04071011.xyz/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
      <category term="2020" scheme="https://04071011.xyz/tags/2020/"/>
    
  </entry>
  
</feed>
