{"meta":{"title":"饼干大超人","subtitle":"给时光以生命，给岁月以文明","description":null,"author":"Simone","url":"https://04071011.xyz"},"pages":[{"title":"关于","date":"2019-01-16T02:52:41.000Z","updated":"2019-03-16T08:45:26.393Z","comments":true,"path":"about/index.html","permalink":"https://04071011.xyz/about/index.html","excerpt":"","text":"&emsp;&emsp;在不久之前就有一点搭建自己的博客的念头，但因为拖延症晚期，一直没能去实现， 最近无意中发现阿里云有一个活动，头脑一热的买了个域名。既然买了域名就要放东西，于是就这么一步步的有了这里的存在。&emsp;&emsp;我还没有想法，在这里存放一些关于我的什么东西，也许是一些生活感悟？大概就是些心灵鸡汤也许是一些教程毕竟老忘事，学了什么记一下也好，也许…说不完的可能性，慢慢写，希望这里能督促我，这样以后回想的时候不会发现自己好像在虚度光阴，总是有留下些什么的……&emsp;&emsp;这里采用的是hexo-theme-random主题，也是我精挑细选实则挑了一天多，最后实在不想再挑的结果，是个很纯净的主题，功能不多，专注写博客。不过说实话到后面就后悔了，毕竟新手上路，什么都想玩一玩，功能都得自己摸索去添加，看着那么多的.swig文件，欲哭无泪，想着应该选个强大的主题，直接配置文件写就行，不过自己选的主题，跪着也要用到最后……是吧 Email:1499832767@qq.com"},{"title":"分类","date":"2019-01-16T02:51:43.000Z","updated":"2019-03-16T08:45:11.300Z","comments":false,"path":"categories/index.html","permalink":"https://04071011.xyz/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-01-16T02:50:36.000Z","updated":"2019-03-16T08:45:22.167Z","comments":true,"path":"tags/index.html","permalink":"https://04071011.xyz/tags/index.html","excerpt":"","text":""},{"title":"search","date":"2019-03-16T12:20:04.000Z","updated":"2019-03-16T12:41:54.384Z","comments":true,"path":"search/index.html","permalink":"https://04071011.xyz/search/index.html","excerpt":"","text":""}],"posts":[{"title":"电商项目记录 - Java项目 - 2020","slug":"电商项目记录","date":"2020-12-18T05:56:47.000Z","updated":"2020-12-30T12:43:28.524Z","comments":true,"path":"2020/12/18/电商项目记录/","link":"","permalink":"https://04071011.xyz/2020/12/18/电商项目记录/","excerpt":"","text":"电商平台学习了很久的java，说的算完整的项目也就是一个博客项目。第四年打算做一个电商项目练习一下学习成果。 前期准备工作 先安装了centos6，在里面搭建环境，以及windows系统的环境准备。安装java、tomcat、maven、vsftpd、git、Nginx、Mysql。 设计数据库表 vsftpd(linux)前面的java、tomcat、maven基本上都是了解过的，这里记录一下新出现的软件工具。 vsftpd是“very secure FTP daemon”的缩写，是一个ftp服务器软件。 FTP协议分为两种一种是PORT方式（主动式），一种是PASV方式（被动式）。 PORT（主动）方式连接过程是，客户端向服务器端FTP端口（默认21）发送链接请求，服务器接收请求建立一条命令链路。当需要传送数据时，客户端在命令链路上用 PORT命令告诉服务器：“我打开了xx端口，你过来连接我”。于是服务器从20端口向客户端的xx端口发送连接请求，建立一条数据链路来传送数据。 PASV（被动）方式的连接过程是：客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用 PASV命令告诉客户端：“我打开了xx端口，你过来连接我”。于是客户端向服务器的xx端口发送连接请求，建立一条数据链路来传送数据。 常用命令： sudo service vsftpd start sudo service vsftpd stop sudo service vsftpd restartNginx Nginx是一款轻量级Web服务器、也是一款反向代理服务器。 具体实现：1.可直接支持Rails和PHP的程序 2.可作为HTTP反向代理服务器 3.作为负载均衡服务器 4.作为邮件代理服务器 5.帮助实现前端动静分离 常用命令 安装路径下/nginx/sbin/nginx -t :测试配置文件 安装路径下/nginx/sbin/nginx :启动命令 安装路径下/nginx/sbin/nginx -s stop 或者 nginx -s quit :停止命令 安装路径下/nginx/sbin/nginx -s reload :重启命令linux记录我从中学到的linux命令 rpm -qa|grep xxxx :这条命令是判断是否安装了xx软件，返回已安装xx软件的版本号 mkdir xxx :创建一个文件夹 cp -r xx ss/ :拷贝xx文件夹所有内容到ss目录下 ps -ef|grep xxxx :查看xxxx进程 kill -HUP xxx进程号 :查看到进程号再使用此命令达到平滑重启MySQL 权限：dql-select,dml-insert update delete ddl-create table create view dcl-grant mysql -u root -p :Linux下进入MySQL select user,host,password from mysql.user 查看当前mysql的用户 set password for root@127.0.0.1=password(‘yourpassword’) :修改root密码 数据表设计用户表(user) 属性 类型 描述 id int 用户id username varchar 用户名 password varchar 密码 email varchar 邮箱 phone varchar 手机号 question varchar 密保问题 answer varchar 密保答案 role int 用户角色 create_time datetime 创建时间 update_time datetime 最后一次更新时间 在数据库中要讲用户名设置一个唯一索引unique,保证数据唯一性。 用户角色，不同数字代表不同角色。 分类表(category) 属性 类型 描述 id int 用户id parent_id int 类别ID name varchar 类别名称 status tinyint 类别状态 sort_order int 排序编号 create_time datetime 创建时间 update_time datetime 最后一次更新时间 parent_id的值为0代表根节点。为其他数据的id值时，代表为那条数据的子节点。 status代表当前分类是否正常被使用 产品表(product) 属性 类型 描述 id int 商品id category_id int 商品分类 name varchar 商品名称 subtitile varchar 商品副标题 main_image varchar 商品主图，url相对地址 sub_images test 商品子图图片地址，json格式 detail text 商品描述 price decimal(20,2) 商品价格保留两位小数，18整数位+2小数位 stock int 商品数量 status int 商品状态 create_time datetime 创建时间 update_time datetime 最后一次更新时间 商品状态分为三种，在售、下架、删除。 购物车表（cart） 属性 类型 描述 id int — user_id int — product_id int 商品id quantity int 商品数量 checked int 是否选择 create_time datetime 创建时间 update_time datetime 最后一次更新时间 checked商品是否被选择 支付信息表（pay_info） 属性 类型 描述 id int — user_id int — order_no bigint 订单号 pay_platform int 支付平台1.支付宝2.微信 platform_number varchar 支付宝支付流水号 platform_status varchar 支付宝支付状态 create_time datetime 创建时间 update_time datetime 最后一次更新时间 订单表(order) 属性 类型 描述 id int — order_no bigint 订单号 user_id int — shipping_id int 订单地址 payment decimal(20,2) 实际付款金额 payment_type int 支付类型 postage int 运费 status int 订单状态 payment_time datetime 支付时间 spend_time datetime 发货时间 end_time datetime 交易完成时间 close_time datetime 交易关闭时间 create_time datetime 创建时间 update_time datetime 最后一次更新时间 订单号为唯一索引 订单明细表(order_item) 属性 类型 描述 id int — order_no bigint 订单号 user_id int — product_id int 商品id product_name varchar 商品名称 payment_image varchar 商品图片地址 current_unit_price decimal 生成订单时的商品单价 quantity int 商品数量 total_price decimal(20,2) 商品总价 create_time datetime 创建时间 update_time datetime 最后一次更新时间 bigint在java中为long类型 收货地址表(shipping) 属性 类型 描述 id int — user_id int — product_id int 商品id receiver_name varchar 收货姓名 receiver_zip varchar 邮编 receiver_phone varchar 电话 receiver_mobile varchar 手机号 receiver_province varchar 省份 receiver_city varchar 城市 receiver_district varchar 区/县 receiver_address varchar 详细地址 create_time datetime 创建时间 update_time datetime 最后一次更新时间 项目构架设计 com.cmall common : 存放项目中的一些常量，拦截异常的公共类等 controller : 前端控制器层。 dao : data accessobject 数据接口访问层。包含各种数据库操作方法。 pojo : 数据库交互的一些数据 service : 数据服务接口层。 util : 工具类库。 vo : value object/view object。视图包装对象，用于封装客户端请求的数据，防止部分数据泄露，保证数据安全。","categories":[{"name":"Java项目","slug":"Java项目","permalink":"https://04071011.xyz/categories/Java项目/"}],"tags":[]},{"title":"数据结构题 - 数据结构 - 2020","slug":"数据结构题","date":"2020-12-10T09:37:29.000Z","updated":"2020-12-30T12:43:28.523Z","comments":true,"path":"2020/12/10/数据结构题/","link":"","permalink":"https://04071011.xyz/2020/12/10/数据结构题/","excerpt":"","text":"Java数据结构题集(2020.9.30)单链表：从尾到头打印单链表（百度面试） 思路： 自己：使用递归实现，遍历单链表，如果没有到末尾，则继续往下找，找到最后一个后打印输出，接着返回上一层继续输出。 尚硅谷：使用Stack栈类实现。 实现：1234567891011121314151617//从尾到头输出单链表（Stack类）public static void reversePrint(HeroNode head)&#123; if (head.next == null)&#123; return; //空链表，不能打印 &#125; //创建一个栈，将各个节点压入栈中 Stack&lt;HeroNode&gt; stack = new Stack&lt;HeroNode&gt;(); HeroNode cur = head.next; while (cur!=null)&#123; stack.push(cur); cur = cur.next; //cur后移，压入下一个节点 &#125; //打印输出栈中的节点 while (stack.size()&gt;0)&#123; System.out.println(stack.pop()); //栈的特点是先进后出 &#125;&#125; Josephu(约瑟夫、约瑟夫环)问题：设编号为1,2, …n的n个人围坐一圈，约定编号为k(1&lt;=k&lt;=n)的人从1开始报数，数到m的那个人出列，它的下一位又从1开始报数，数到m的那个人又出列，依次类推，直到所有人出列为止，由此产生一个出列编号的序列。 思路： 尚硅谷：构建一个单向的环形链表。先创建一个辅助(指针)变量，事先指向环形链表最后一个节点。当小孩报数时，让first和helper指针同时移动m-1次。first指向的小孩出圈就是让helper指向小孩的下一个节点。原来的first指向的节点没有引用就会变回收。 实现:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @Description 根据用户输入，计算出小孩出圈的顺序 * @Param startNo : 表示从第几个小孩开始数数 * @Param countNum : 表示数几下 * @Param nums : 表示最初有多少小孩在圈内 * @return void**/public void countBoy(int startNo,int countNum,int nums)&#123; //先对数据进行校验 if (first == null || startNo &lt; 1 || startNo &gt; nums) &#123; System.out.println(\"参数输入有误，请重新输入\"); return; &#125; //创建要给辅助指针，帮助完成小孩出圈 Boy helper = first; //需求创建一个辅助指针(变量)helper,事先应该指向环形链表的最后这个节点 while(true) &#123; if (helper.getNext()==first)&#123; break; &#125; helper = helper.getNext(); &#125; //小孩报数前，先让first和helper移动k-1次 for (int j = 0; j &lt; startNo-1; j++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //出圈 让first 和 helper同时移动m-1次 while (true)&#123; if (helper == first)break; //说明圈中只有一个节点 //同时移动countNum-1，数数ing for (int i = 0; i &lt; countNum - 1; i++) &#123; first = first.getNext(); helper = helper.getNext(); &#125; //出圈 System.out.printf(\"小孩%d出圈\\n\",first.getNo()); first = first.getNext(); helper.setNext(first); &#125; System.out.println(\"最后留在圈中的小孩编号为\"+helper.getNo());&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://04071011.xyz/categories/数据结构/"}],"tags":[]},{"title":"2020.12.8","slug":"2020-12-8","date":"2020-12-08T09:27:32.000Z","updated":"2020-12-30T12:43:28.514Z","comments":true,"path":"2020/12/08/2020-12-8/","link":"","permalink":"https://04071011.xyz/2020/12/08/2020-12-8/","excerpt":"","text":"JAVA多线程Thread中常用方法 start() 启动当前线程：调用线程的run方法 run() 通常需要重写Thread类中的此方法，将创建线程需要做的操作声明在此方法中 currentThread() 静态方法，返回执行当前代码的线程 getName() 获取当前线程的名字 setName() 创建当前线程的名字 yield() 释放当前cpu的控制权 join() 在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行后，线程a才结束阻塞状态 stop() 此方法已过时，调用此方法，强制结束当前线程线程的调度 调度策略 时间片 抢占式：高优先级的线程抢占cpu Java的调度方法 同优先级线程组先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略线程的优先级 MAX_PRIORITY:10 MIN_PRIORITY:1 NORM_PRIORITY:5 默认线程优先级为5涉及的方法 getPriority():返回的线程优先值 getPriority(int new Priority):改变线程的优先级","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.11.5","slug":"2020-11-5","date":"2020-11-05T09:07:47.000Z","updated":"2020-12-30T12:43:28.513Z","comments":true,"path":"2020/11/05/2020-11-5/","link":"","permalink":"https://04071011.xyz/2020/11/05/2020-11-5/","excerpt":"","text":"Java异常手动抛出异常throw new xxx(“”); 自定义异常 需要继承现有的异常类 提供全局常量：serialVersionUID 提供重载的构造器","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.11.3","slug":"2020-11-3","date":"2020-11-03T09:23:47.000Z","updated":"2020-12-30T12:43:28.514Z","comments":true,"path":"2020/11/03/2020-11-3/","link":"","permalink":"https://04071011.xyz/2020/11/03/2020-11-3/","excerpt":"","text":"Java异常throws + 异常类型 “throws + 异常类型”写在方法声明处。指明此方法执行时，可能会抛出的异常类型。一旦方法体执行时，出现异常，仍然会在异常代码处生成一个异常对象。此对象满足throws异常类型时，就会被抛出。如何选择try-catch-finally还是throws 如果父类被重写的方法没有throws方式处理异常，则子类重写的方法不能使用throws，意味着如果子类重写的方法中有异常，则必须使用try-catch-finally方式处理。 执行的方法中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。那么建议使用throws的方式进行集中处理。而执行的方法可以考虑使用try-catch-finally方式处理异常。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.11.2","slug":"2020-11-2","date":"2020-11-02T08:39:07.000Z","updated":"2020-12-30T12:43:28.512Z","comments":true,"path":"2020/11/02/2020-11-2/","link":"","permalink":"https://04071011.xyz/2020/11/02/2020-11-2/","excerpt":"","text":"Java异常异常的处理：抓抛模型 过程一：”抛”：程序在正常执行过程中，出现异常，就会在异常代码处生成一个对应异常类的对象。并将此对象抛出。一旦抛出，后面代码不执行。 过程二：”抓”：可以理解为异常的处理方式。①try-catch-finally ②throwstry-catch-finally的使用···Javatry{ //可能出现的异常代码}catch(异常类型1 变量名1){ //处理异常的方法1}catch(异常类型2 变量名2){ //处理异常的方法2}catch(异常类型3 变量名3){ //处理异常的方法3}…..finally{ //一定会执行的代码}··· finally是可选的。 使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去catch中进行匹配。 一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常处理。一旦处理完成，就跳出当前的try-catch结构(在没有写finally的情况)。 catch中异常类型，如果没有子父类关系，谁先谁后无所谓。如果满足，则子类一定声明在父类上方，否则报错。 常用异常对象处理方式：①String getMessage(); ②printStackTrace(); finally中声明的是一定会执行的代码。即使catch中出现了异常，try、catch中有return语句。 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要手动释放资源。此时就需要声明在finally中。 try-catch-finally结构可以嵌套。 ### 使用try-catch-finally处理编译时异常，使得程序在编译时不在报错，但运行实施可能还会报错。相当于我们将一个编译时可能出现的异常延迟到运行时出现。 开发中，由于运行时异常比较常见，所以我们通常不针对运行时异常编写try-catch-finally了。正对编译时异常，我们一定要考虑异常的处理。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.29","slug":"2020-10-29","date":"2020-10-29T08:37:32.000Z","updated":"2020-12-30T12:43:28.511Z","comments":true,"path":"2020/10/29/2020-10-29/","link":"","permalink":"https://04071011.xyz/2020/10/29/2020-10-29/","excerpt":"","text":"Java异常Error Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverflowError(栈溢出)和OOM(堆溢出)。 一般不编写针对性的代码。Exception 其它因为编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。比如空指针访问、试图读取不存在的文件、网络连接中断、数组角标越界等。异常体系结构 java.lang.Throwable java.lang.Error:一般不编写针对性代码进行处理 java.lang.Exception:可以进行异常的处理 编译时异常(受检checked异常) IOException FileNotFoundException ClassNotFoundException 运行时异常(非受检unchecked异常) NullPointerException ArrayIndexOutOfBoundsException ClassCastException NumberFormatException InputMismatchException ArithmeticException","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.26","slug":"2020-10-26","date":"2020-10-26T08:01:27.000Z","updated":"2020-12-30T12:43:28.508Z","comments":true,"path":"2020/10/26/2020-10-26/","link":"","permalink":"https://04071011.xyz/2020/10/26/2020-10-26/","excerpt":"","text":"Java内部类 Java中允许将一个类A声明在一个类B中，则类A就是内部类 内部类的分类： 成员内部类：静态、非静态 局部内部类：方法内、代码块内、构造器内 匿名内部类 静态内部类 成员内部类：一方面作为外部类的成员，一方面作为一个类。 内部类调用外部类的属性时，可以使用外部类.this.xxx的方式调用。 为什么要使用内部类？ 每个内部类都能独立的继承一个接口的实现，无论外部类是否继承了某个(接口的)实现。内部类使多继承的解决方案变得完整。 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 方便编写事件驱动程序。 方便编写线程代码。 成员内部类实例化成员内部类的对象 静态的成员内部类 外部类.成员内部类 xx = new 外部类.成员内部类(); （非静态的成员内部类） 先实例化一个外部类的对象 外部类.内部类 xxx = 外部类对象.new 成员内部类();","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.22","slug":"2020-10-22","date":"2020-10-22T08:15:32.000Z","updated":"2020-12-30T12:43:28.510Z","comments":true,"path":"2020/10/22/2020-10-22/","link":"","permalink":"https://04071011.xyz/2020/10/22/2020-10-22/","excerpt":"","text":"数据结构栈逆波兰计算器输入一个逆波兰表达式(后缀表达式)，使用栈(Stack)，计算其结果，支持小括号和多位整数。将中缀表达式转成后缀表达式的思路： 先设定两个栈，s1和s2。s1为运算符栈，s2为储存中间结果的栈。 从左至右扫描中缀表达式。 如果遇到操作数则压入s2中。 如果遇到操作符，比较其与s1栈顶的运算符优先级。 如果s1位空或栈顶运算符位左括号“（”，则直接将此运算符入栈； 否则如果当前操作符的优先级比s1栈顶的优先级高，则直接入栈； 否则，将s1栈顶的运算符弹出压入到s2中，再次转到 4.1 与s1中的新栈顶运算符比较。 遇到括号时： 如果为左括号“（”，则直接压入s1； 如果遇到右括号“）”，则依次弹出s1中栈顶的运算符，放入s2中，直到遇到左括号为止，此时这一对括号丢弃。 重复步骤2至5，直到表达式最右边。 将s1中剩余的运算符依次弹出并压入s2中。 依次弹出s2中元素并输出，结果的逆序即为中缀表达式对应的后缀表达式。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.20","slug":"2020-10-20","date":"2020-10-20T08:11:52.000Z","updated":"2020-12-30T12:43:28.509Z","comments":true,"path":"2020/10/20/2020-10-20/","link":"","permalink":"https://04071011.xyz/2020/10/20/2020-10-20/","excerpt":"","text":"数据结构栈(stack) 栈是一个先入后出的有序列表 栈是限制线性表中元素的拆入和删除只能在线性表的同一端进行的一种特殊的线性表。允许插入和删除的一端为栈顶(Top),固定的一端，为栈底(Bottom)。 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶。删除时，最先放入的元素最后删除，最后放入的元素最先删除。栈的应用 子程序的调用 处理递归调用 表达式的转换与求值 二叉树的遍历 图形的深度优先搜索法","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.19","slug":"2020-10-19","date":"2020-10-19T08:06:02.000Z","updated":"2020-12-30T12:43:28.507Z","comments":true,"path":"2020/10/19/2020-10-19/","link":"","permalink":"https://04071011.xyz/2020/10/19/2020-10-19/","excerpt":"","text":"JAVA接口 implements 开发中可使用四种方法传参，当形参为接口时。 传入接口的非匿名实现类的非匿名对象。 传入接口的非匿名实现类的匿名对象。 传入接口的匿名实现类的非匿名对象。 传入接口的匿名实现类的匿名对象。 在子类(或实现类)的方法中调用父类、接口中被重写的方法 调用自己定义重写的方法(方法体();) 调用父类中的声明的方法(super.方法体();) 调用接口中默认方法(接口.super.方法体();)接口的应用 代理模式(Proxy) 代理模式是Java开发中使用最多的设计模式。代理模式就是为其他对象提供一种代理以控制对这个对象的访问。 应用场景 安全代理：屏蔽对真实角色的直接访问 远程代理：通过代理类处理远程方法调用(RMI) 延迟加载：先加载轻量级的代理对象，真正需要在加载真实对象。 分类 静态代理(静态定义代理类) 动态代理(动态生成代理类) 工厂模式 实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 就是创建对象的。 设计原则 OCP(开闭原则，Open-Closed Principle) DIP(依赖倒转原则，Dependence Inversion Principle) LOD(迪米特法则，Law Of Demeter) 分类 简单工厂模式 工厂方法模式 抽象工厂模式","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.12","slug":"2020-10-12","date":"2020-10-12T08:33:02.000Z","updated":"2020-12-30T12:43:28.507Z","comments":true,"path":"2020/10/12/2020-10-12/","link":"","permalink":"https://04071011.xyz/2020/10/12/2020-10-12/","excerpt":"","text":"JAVA模板方法设计模式(TemplateMethod)抽象类体现的就是一种模板模式的设计。抽象类作为多个子类的通用模板，子类在抽象类的基础上扩展、改造，但总体上会保留抽象类的行为方式。 模板方法设计要求软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但某些易变的部分可以抽象出来，让不同的子类实现。 Calendar类可以获取当前日期。12Calendar calendar = Calendar.getInstance();int mouth = calendar.get(Calendar.MONTH); //获取当前月份 接口 implements123interface XX&#123; &#125; JAVA不支持多继承，有了接口就可以得到多继承的效果 接口和类是并列的结构 JDK7及以前：只能定义全局常量和抽象方法 全局常量：public static final的(书写时可以省略) 抽象方法：public abstract的 JDK8：除了全局常量和抽象方法外，还可以定义静态方法和默认方法 接口中无法定义构造器，意味着接口无法实例化 实现类覆盖了接口中的所有抽象方法，则此实现类可以实例化 如果实现类没有覆盖接口中的所有抽象方法，则此类仍为一个抽象类 如果实现类需要继承父类，则先写继承后写接口 接口与接口之间是多继承的 接口实际就是定义了一种规范 接口也满足多态性 接口中定义的静态方法，只能通过接口来调用","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.10","slug":"2020-10-10","date":"2020-10-10T08:02:12.000Z","updated":"2020-12-30T12:43:28.505Z","comments":true,"path":"2020/10/10/2020-10-10/","link":"","permalink":"https://04071011.xyz/2020/10/10/2020-10-10/","excerpt":"","text":"Javafinal 关键字 可以用来修饰方法、类、属性 被final修饰的类无法被继承，被final修饰的方法无法被重写，被final修饰的属性的值无法被修改（即为常量） final修饰的属性可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化 static final 用来修饰属性：全局常量，修饰方法：无法被重写的静态方法 abstract关键字 不能修饰属性、构造器等结构 不能修饰私有方法、静态方法、final的方法、final的类抽象类 abstract修饰的类不能实例化 抽象类中一定有构造器，便于子类实例化时调用 开发中都会提供抽象类的子类，让子类对象实例化，完成相关操作抽象类的匿名子类设Pe为抽象类，创建一个Pe的匿名子类。抽象类是无法实例化的。1234Pe pe = new Pe()&#123; //方法体 ......&#125; 抽象方法 抽象方法没有方法体，只有声明 有抽象方法的类一定是抽象类，抽象类中不一定有抽象方法 若子类重写了父类中的抽象方法，子类可以实例化 子类中没有重写父类中所有的抽象方法，则子类还是个抽象类","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.10.9","slug":"2020-10-9","date":"2020-10-09T09:02:12.000Z","updated":"2020-12-30T12:43:28.512Z","comments":true,"path":"2020/10/09/2020-10-9/","link":"","permalink":"https://04071011.xyz/2020/10/09/2020-10-9/","excerpt":"","text":"Javastaticstatic修饰方法：静态方法 随着类的加载而加载，可以通过“类.静态方法”的形式调用 静态方法中只能调用静态的方法或属性非静态的方法中，既可以调用非静态的属性也可以调用静态的属性（因为静态与非静态的生命周期不同）static注意点：在静态的方法中，不能使用this、super关键字 开发中如何确定一个属性是否声明为static？ 1属性可以被多个对象共享，不会随着对象的不同而不同 开发中如何确定一个方法是否声明为static？ 121. 操作静态属性的方法通常设置为static2. 工具类中的方法，习惯上声明为static的 设计模式设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。设计模式一共有23种： 创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 结构型模式（7种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式单例设计模式采用一定的方法在整个软件系统中，对某个类只能存在一个对象实例，且该类只提供一个取得其对象实力的方法。饿汉式实现 私有化类的构造器 内部创建类的（静态）对象 提供公共（静态）的方法，返回类的对象懒汉式实现 私有化类的构造器 声明当前类（静态）对象，没有初始化。 声明公共静态的方法，在方法内部判断当前声明对象是否为空，为空初始化类对象，返回当前类的对象区分 饿汉式 和 懒汉式|名称|缺点|优点||:—:|:—|:—||饿汉式|对象加载时间过长|是线程安全的||懒汉式|没使用多线程写法时是线程不安全的|延迟对象的创建|单例模式的优点由于单例设计模式只产生一个实例，减少了系统性能开销应用场景 网站计数器 应用程序的日志应用 数据库连接池 读取配置文件的类 Application Windows 的任务管理器 Windows 的回收站 main()方法 程序的入口 是一个普通的静态的方法 main()方法的参数可以作为与控制台交互的一种方法 代码块(初始化块) 用来初始化类、对象 只能使用 static 修饰 static代码块随着类的加载而执行，而且只执行一次 非static代码块随着对象的创建而执行 非static代码块可以在创建对象时，对对象的属性进行初始化 1234567891011public class Xxx&#123; ...... &#123; //我是一个代码块 &#125; static &#123; //我是一个静态的代码块 &#125; ......&#125; 数据结构双向链表单向链表缺点：无法自我删除，查找只能是一个方向。双向链表优点：可以向前或向后查找、可以自我删除。单向链表vs双向链表不同点：添加、修改、删除不同外基本一致","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.30","slug":"2020-9-30","date":"2020-09-30T09:17:22.000Z","updated":"2020-12-30T12:43:28.522Z","comments":true,"path":"2020/09/30/2020-9-30/","link":"","permalink":"https://04071011.xyz/2020/09/30/2020-9-30/","excerpt":"","text":"Java内存内存中，栈主要存放局部变量、堆主要存放new出来的结构（对象、数组），方法区主要存放类的加载信息、静态域、常量池。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.29","slug":"2020-9-29","date":"2020-09-29T09:16:32.000Z","updated":"2020-12-30T12:43:28.519Z","comments":true,"path":"2020/09/29/2020-9-29/","link":"","permalink":"https://04071011.xyz/2020/09/29/2020-9-29/","excerpt":"","text":"Javastatic关键字可以用来修饰：属性、方法、代码块、内部类使用static修饰的属性：静态变量（类变量）1234567属性:按是否使用static修饰，分为：静态属性 vs 非静态属性(实例变量) 实例变量：创建类的多个对象，每个对象都独立的拥有一套类中非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值修改 静态变量：创建类的多个对象，多个对象共享同一个静态变量。当修改某一个对象中的静态变量时，其他的对象中的静态变量也会修改。其他说明： 1. 静态变量随着类的加载而加载，可以通过“类.静态变量”的方式调用 2. 静态变量的加载要早于对象 3. 类只会加载一次，则静态变量在内存中也只存在一份，存在方法的静态域","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.27","slug":"2020-9-27","date":"2020-09-27T09:15:22.000Z","updated":"2020-12-30T12:43:28.521Z","comments":true,"path":"2020/09/27/2020-9-27/","link":"","permalink":"https://04071011.xyz/2020/09/27/2020-9-27/","excerpt":"","text":"JAVA多态性含义：一个事物的多种形态在Java中，父类的引用可以指向子类的对象，通过此引用调用的方法为子类重写的方法（没有重写的也可以，但那就没必要了）使用：虚拟方法调用，编译看左边，运行看右边。当父类中不存在子类中有的方法时，无法调用。属性的调用还是父类的属性。使用前提：1. 类的继承性 2. 方法重写 虚拟方法调用定义：子类中定义了与父类同名同参数的方法，在多态的情况下，此时父类的方法叫虚拟方法。父类根据赋给它不同的子类对象，动态调用属于子类的该方法。在编译期无法确定实际调用的方法。 向下转型子类的引用指向父类，父类使用强制类型转换符。可能出现ClassCastException的异常。 instanceof使用：a instanceof A判断对象a是否是类A的实例，如果是返回true。为了避免出现异常。 Object类所有Java类的根父类。一个类如果没有使用extends关键字指明其父类，则默认为java.lang.Object类。 主要结构 序号 方法名 类型 描述 1|public Object()|构造|构造器2|public boolean equals(Qbject obj)|普通|对象比较3|public int hashCode()|普通|取得Hash码4|public String toString()|普通|对象打印时调用v == 运算符 可以使用在基本数据类型变量和引用数据类型变量中 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等（不一定类型相等）。 如果比较的是引用类型变量：比较两个对象地址值是否相同，即两个引用是否指向同一个对象实体。equals()方法 只适用于引用数据类型 Object类中定义的equals()和==的作用是相同的，比较两个对象的地址值是否相同 像String、Date、File、包装类等都重写了Object类的equals()方法，比较的是两个对象的实体内容是否相同。 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象‘实体内容’是否相同，我们需要对此方法进行重写。 重写equals()方法的原则对称性、自反性、传递性、一致性","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.22","slug":"2020-9-22","date":"2020-09-22T09:05:25.000Z","updated":"2020-12-30T12:43:28.520Z","comments":true,"path":"2020/09/22/2020-9-22/","link":"","permalink":"https://04071011.xyz/2020/09/22/2020-9-22/","excerpt":"","text":"JAVAObject如果我们没有显式声明一个类的父类，则此类继承于java.lang.Object类。所有的java类(除java.lang.Object类之外)，都直接或间接继承于java.lang.Object类。 重写(override / overwrite) 子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作 应用：重写以后，当创建子类对象以后，通过子类v对象调用子父类中的同名同参数的方法时，执行的时子类从写父类的方法。 重写的规定： 方法的声明： 权限修饰修饰符 返回值类型 方法名(形参列表) throws 异常的类型{ //方法体 } 约定俗成：子类中的叫重写的方法，父类中叫被重写的方法 子类重写的方法的方法名和形参列表与父类中被重写的方法相同 子类中重写的方法的权限修饰符，不小于父类中被重写的方法的权限修饰符 特殊情况：子类不能重写父类中声明为private权限的方法 返回值类型： 父类被重写的方法返回值类型为void的，重写的方法也必须是void 父类被重写的方法的返回值为A类型，则重写的方法的返回值可以是A类或A类的子类 父类被重写的方法的返回值是基本数据类型，则重写方法也必须是相同的数据类型 子类重写的方法抛出的异常不大于父类被重写方法的异常类型 子类和父类中同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static（不是重写）","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.21","slug":"2020-9-21","date":"2020-09-21T08:39:05.000Z","updated":"2020-12-30T12:43:28.518Z","comments":true,"path":"2020/09/21/2020-9-21/","link":"","permalink":"https://04071011.xyz/2020/09/21/2020-9-21/","excerpt":"","text":"JAVAMVC设计模式MVC是常用的设计模式之一，将程序分为三层，降低程序耦合性。 M 是 数据模型层 ModelV 是 视图模型层 ViewC 是 控制器层 Controller model层 主要处理数据： 数据对象封装 model.bean/domain数据库操作对象 model.dao数据库 model.db controller层 处理业务逻辑： 应用界面相关 controller.activity存放fragment controller.fragment显示列表的适配器 controller.adapter服务相关 controller.service抽取的基类 controller.base view层 显示数据： 相关工具类 view.utils自定义view view.ui import 关键字import:导入 在源文件中显式的使用import结构导入指定包下的类、接口 import的声明在包的声明和类的声明之间 如果需要导入多个结构，并列写出 可以使用“xxx.*”的方式，导入xxx包下所有的结构 如果使用的类或接口是java.lang包下定义，可以不用导入 如果使用的类或接口是本包下定义的，可以省略import结构 如果碰到两个重名的类，有一个需要使用全类名方式显示 使用“xxx.*”方式调用xxx包下所有所有的结构，但是xxx包下的子包，仍需要显式导入 import static:导入指定类或接口中静态的结构v 继承一、继承的好处： 减少了代码冗余，提高了代码的复用性 便于功能的扩展 为了之后多态性的使用，提供了前提二、继承的格式123class A extends B&#123; .....&#125; A:子类、派生类，subclassB:父类、基类，superclass 体现：一旦子类A继承父类B以后，子类A就获取了父类B中声明的结构、属性、方法。父类中声明为private的属性或方法，子类继承父类以后，仍然获取了父类中的私有结构。只因为有封装性的影响，使得子类不能直接调用父类的结构。 子类继承父类以后，还可以声明自己特有的属性或方法，实现功能扩展。子类和父类的关系，不同于子集和集合的关系。三、关于继承的规定 一个类可以被多个子类继承 一个子类不允许有多个父类，这是Java的单继承性 子父类是相对的概念 子类继承父类，就获取了直接父类和所有间接父类中声明的属性和方法","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.18","slug":"2020-9-18","date":"2020-09-18T08:35:15.000Z","updated":"2020-12-30T12:43:28.516Z","comments":true,"path":"2020/09/18/2020-9-18/","link":"","permalink":"https://04071011.xyz/2020/09/18/2020-9-18/","excerpt":"","text":"算法稀疏数组 what？：压缩数组的一种方式。 why？：原数组中有大量重复无意义的数据，为了解决内存空间浪费的问题，所以使用稀疏数组压缩原数组，节省内存空间。 how？： 数组的第一列存放原数组的行数，第二列存放原数组的列数，第三列存放原数组对应行列中存放的值。 二维数组 转 稀疏数组 1.遍历原始的二维数组，得到有效数据的个数sum2.根据sum就可以创建稀疏数组spareArr int[sum+1][3]3.将二维数组的有效数据存入到稀疏数组 稀疏数组转原始二维数组 1.先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组2.读取第一行以后的数据，存入到二维数组中即可 思路根据尚硅谷的课程学习而来","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.17","slug":"2020-9-17","date":"2020-09-17T08:32:42.000Z","updated":"2020-12-30T12:43:28.518Z","comments":true,"path":"2020/09/17/2020-9-17/","link":"","permalink":"https://04071011.xyz/2020/09/17/2020-9-17/","excerpt":"","text":"JAVA基础的查漏补缺最近的两周时间在看尚硅谷的Java基础视频，说起来还有点不好意思。我夸大了来说是学了两年的Java吧，但实际敲代码，一直学习的时间加在一起也就是两个学期多，一年左右。一直觉得我基础并不是很好，但是又不知道究竟差在哪，感觉都不太会，又感觉大部分基础都会了。最终还是选择去看基础视频，碰到觉得会的就跳过，如果觉得知识点还比较模糊的就停下来好好看看，查漏补缺，增强记忆。看了快两周，最大的感悟就是，我早应该看的，不应该犹豫拖延。不会就是不会，虽然说好像现在还学基础就很晚了，但是再晚还是得学，基础不打好，直接学高级到后面也还是懵圈的学。下面就总结一下这两周学的内容。 this关键字123456789101112131415161718192021this关键字的使用：1.this可以用来修饰、调用：属性、方法、构造器2.this修饰属性和方法： this理解为：当前对象 或 当前正在创建的对象 2.1 在类的方法中，我们可以使用&quot;this.属性&quot;或&quot;this.方法&quot;的方式，调用当前对象属性或方法。但是， 通常情况下，我们都选择省略&quot;this.&quot;。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式 的使用&quot;this.变量&quot;的方式，表明此变量是属性，而非形参。 2.2 在类的构造器中，我们可以使用&quot;this.属性&quot;或&quot;this.方法&quot;的方式，调用当前正在创建的对象属性或方法。 但是，通常情况下，我们都选择省略&quot;this.&quot;。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式 的使用&quot;this.变量&quot;的方式，表明此变量是属性，而非形参。3.this调用构造器 ① 我们在类的构造器中，可以显式的使用&quot;this(形参列表)&quot;方式，调用本类中指定的其他构造器 ② 构造器中不能通过&quot;this(形参列表)&quot;方式调用自己 ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了&quot;this(形参列表)&quot; ④ 规定：&quot;this(形参列表)&quot;必须声明在当前构造器的首行 ⑤ 构造器内部，最多只能声明一个&quot;this(形参列表)&quot;，用来调用其他的构造器###### 以上内容来自尚硅谷视频 以前使用this关键字时，一般都是凭直觉，我觉得这个地方应该可以用this就用，没报错就继续往下写，报错了就换个方法写。重点记住this的使用对象（属性、构造器、方法），以及this的含义（当前对象、当前正在创建的对象）即可。很新奇的是this调用构造器，可以直接this()，这个视角很巧妙。 算法字符串匹配算法问题，可使用暴力破解和KMP算法解决问题。暴力算法：简单但效率低还未学到KMP，但我的想法是： 获取被匹配字符串以及需要匹配字符串的首字符和长度对被匹配字符串进行分割，使用for循环，如果遇到与首字符相等的字符，则获取当前字符以及后面与需要匹配字符串长度的字符串，存放在一个数组中，顺便记住字符位置。继续循环，重复操作。最后循环匹配，看看有多少个成功匹配，如果没有返回-1","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"2020.9.14","slug":"2020-9-14","date":"2020-09-14T08:54:42.000Z","updated":"2020-12-30T12:16:02.974Z","comments":true,"path":"2020/09/14/2020-9-14/","link":"","permalink":"https://04071011.xyz/2020/09/14/2020-9-14/","excerpt":"","text":"数据结构——大O表示法数据结构中算法的空间、时间复杂度一直不是很清楚，看了一遍又一遍但还是没有搞懂的很彻底。处于一种感觉理解又好像不理解的地步，今天就仔仔细细的学一学。首先弄懂时间复杂度吧。 时间复杂度「 大O符号表示法 」是我们表示一个算法所消耗时间的方法，即 T(n) = O(f(n))。它不是表示出一个代码的具体执行时间，而是表示代码执行时间的变化趋势，它也被称作算法的渐进时间复杂度。 推导大O阶的方法 1.用常数1取代运行时间中的发所有加法常数2.在修改后的运行次数函数中，只保留最高阶项3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。 以上内容来自《大话数据结构》P30我觉得简单来说就是结果中含有加法常数的可以省略，去除非最高项的项，与常数相乘的项如果非1，则去除这个常数。例子：O(3n^2+2n+1)=&gt;O(n^2)。 常数阶O(1)1234int sum=0,n=999;sum++;++n;system.out.println(&quot;sum&quot;); 代码块中没有涉及到循环等其他复杂的结构，那么这个代码块的时间复杂度就是O(1)。上面的代码，运行次数函数是f(n)=4,根据推导大O阶的方法，f(n)=1。所以无论上方的代码执行多少次，最终f(n)还是等于1。 线性阶O(n)12345for(i=1; i&lt;=n; ++i) //执行n次&#123; j = i; //执行1次 j++; //执行1次&#125; 这段代码，其实不难看懂。不过有一个疑惑的点，我在看《大话数据结构》时间复杂度一章时，第一行 for 循环的代码，书上计算的是执行n+1次。虽然+1和不+1的区别并不是很大，最终的结果都是 O(n) ,我们也只是需要知道代码的时间增长趋势，但就是纠结这个问题。网上搜索也并没有人提过这个问题，有一个版本的教材前面出现这部分代码时写的是n+1，到了后面就变成了n次。按照我的计算来看，就是n次。得到计算结果后，常数项可以省略。 对数阶O(logN)1234int i=0;while (i&lt;n)&#123; i = i*5;&#125; 每一轮i都会*5，直到i&gt;n才会结束循环。所以5^x=n,x=log5^n。根据我们推导大O阶方法的第三条可得,这段代码的时间复杂度为O(logN)。 线性对数阶O(nlogN)123456for(m=0;m&lt;n;m++)&#123; int i=0; while (i&lt;n)&#123; i = i*5; &#125;&#125; 线性对数阶就是将时间复杂度为O(logN)的代码循环N遍。 平方阶O(n^2)1234567for(i=1; i&lt;=n; ++i) //执行n次&#123; for(j=1;j&lt;=n;j++)&#123; //执行n^2次 j = i; //执行1次 j++; //执行1次 &#125;&#125; 平方阶就是将O(n)的代码循环嵌套一遍，也就是O(n*n)=&gt;O(n^2)次。这个也比较好理解，把之前的掌握后，就容易理解了。 立方阶O(n^3)、K次方阶O(n^k)这两种与平方阶类似，多层循环嵌套。","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/categories/日常记录/"}],"tags":[{"name":"日常记录","slug":"日常记录","permalink":"https://04071011.xyz/tags/日常记录/"},{"name":"2020","slug":"2020","permalink":"https://04071011.xyz/tags/2020/"}]},{"title":"jsp学生管理系统","slug":"jsp学生管理系统","date":"2019-05-18T03:31:22.000Z","updated":"2020-12-30T12:20:48.641Z","comments":true,"path":"2019/05/18/jsp学生管理系统/","link":"","permalink":"https://04071011.xyz/2019/05/18/jsp学生管理系统/","excerpt":"","text":"这学期上了JSP课，虽然说这门技术已经落后了，但抱着“多学一点总没错”的心理还是学了这门课。期中的作业项目是做一个学生管理系统，本可以用spring写的，但是这是个小组作业嘛，总是要顾及一下同学的，毕竟她们还没学，而且也顺带巩固一下jsp，不然连作品都没有，白上半个学期的课了。回归正题，我就在这写一份教程，一是为了传播知识…（虽然不知道会不会有人看）二就是为了让自己以后能快速回顾，好记性不如烂笔头，三就是锻炼自己的写作能力，经常看到一些博主说，多写技术文档对自己是挺有益的。首先我们先分析一个学生管理系统需要有什么功能。 登陆功能（login.jsp） 注册功能（register.jsp） 找回密码功能（forgotPWD.jsp + setPWD.jsp） 修改个人信息功能（updateUser.jsp） 查看所有学生功能（selectStudent.jsp） 添加学生信息功能（addStudent.jsp） 修改学生信息功能（updateStudent.jsp） 删除学生信息功能（delStudent.jsp） 总的来说，基本就以上八种功能，这八种功能无非就是对数据的增删查改，也就是说我们只要能把登陆、注册、找回密码这三个功能做出来，后面那些简直 so easy ！我们先来想想登陆、注册页面需要些什么功能，首先是用户得要输入用户名和密码，一般网站登陆时都得输入验证码对吧，所以我们需要做一个验证码功能。接着是找回密码功能，这个功能就有点复杂，我们不可能说用户想随便找回密码就能找回吧，得确认用户的身份，身份确认的话，就在注册时让用户输入一个邮箱，用户找回密码的时候，就给当时用户注册时填写的邮箱发一封含有验证码的邮件，用户输入正确的验证码才能进行找回密码操作，这样就确定了用户的身份。一般我们都不会直接告诉用户旧密码是什么吧，所以就让用户直接设置新的密码即可。这就确定了两点，一是做一个验证码功能，二是邮件功能。开工吧！ 我们先来连接数据库，这是一个重要的一步，数据库连接出错后面就全盘崩掉。 连接数据库首先，我们在Java Resources下的src目录下建一个包，包名为 com.db.tools ，接着再新建一个类，类名为 DbUtil 。这个类功能就是连接我们的数据库，并提供我们操作数据的方法。这里我使用的是mysql数据库，去 mysql 的官网下载驱动包，我使用的是5.1.44版本。把jar包拖到项目的 Java Resources–WebContent–WEB-INF–lib 下，接着右键 jar 包，找到 Build Path 单击 Add to Build Path 。这一步是把 jar 添加到项目的环境变量中，防止后续出现莫名的错误。导入jar包后，我们就可以来连接数据库了。我的数据库中一共有两张表，一张是用户表，一张时学生信息表。字段名分别为： tb_user:user_no(自增长)、user_number、user_name、user_sex、user_birthday、user_mail、user_pwdtb_student:stuNo、stu_name、stu_sex、stu_nativeplace、stu_birthday、stu_classname 数据库建好后，打开DbUtil类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.db.tools;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class DbUtil &#123; //定义数据库连接类对象 private Connection conn = null; //定义执行SQL查询语句的API对象 private PreparedStatement pstmt = null; //定义存放结果集类的对象 private ResultSet rs = null; public DbUtil() throws ClassNotFoundException, SQLException &#123; //加载mysql驱动 Class.forName(\"com.mysql.jdbc.Driver\"); //连接数据库，注意这里要把 database 改成自己的数据库名，root改成数据库的用户名，password 改成数据库的密码 conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/database?user=root&amp;password=password\"); &#125; //查询方法，返回类型为ResultSet public ResultSet dbQuery(String sql) throws SQLException&#123; //加载sql语句 pstmt = conn.prepareStatement(sql); //调用查询方法，把查询到的结果存放在rs中 rs=pstmt.executeQuery(); return rs; &#125; //更新方法，返回类型为boolean public boolean dbUpdate (String sql) throws SQLException&#123; //加载sql语句 pstmt = conn.prepareStatement(sql); //调用更新方法，如果更新成功则返回true if(pstmt.executeUpdate()&gt;0)&#123; return true; &#125;else&#123; return false; &#125; &#125;&#125; 以上就是连接数据库，并对数据库进行查询和更改的方法。连接完了数据库我们就可以开始往后写了。接着实现验证码功能。 验证码我们在 com.db.tools 包中新建一个类，名为 CodeServlet 。我们来想一想，验证码要怎么做。首先，验证码肯定是随机的，不能按顺序，随机的话，那就是用到 java 的随机函数，Random 类，所以我们需要创建一个Random 对象得到一个随机数。随机数给它一个范围，所以我们就要建立一个数组存放我们需要的范围数，如（1，2，3，4，5，6，y，z，j），这样我们生成的数就只会是这些数内的，不可能出现 A，B，c 这些不在括号内的数。确定范围后，我们还需要确定我们的验证码需要几位字母，我想的是5位，不会太多不会太少，你可以根据你的想法定义。接着，得到了一个随机的验证码之后，我们需要一个背景，不能让一些机器轻松的识别到，防止恶意登录注册，所以我们需要绘制生成一张色彩较为混乱的图片。再将验证码与图片混合。这样一张验证码图片就完成了。讲完了思路，我们来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import java.awt.Color;import java.awt.Font;import java.awt.Graphics2D;import java.awt.image.BufferedImage;import java.io.IOException;import java.util.Random;import javax.servlet.ServletException;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.apache.catalina.Session;import com.sun.image.codec.jpeg.JPEGCodec;import com.sun.image.codec.jpeg.JPEGImageEncoder;public class CodeServlet extends HttpServlet &#123; public static final char[] chars=&#123;'2','3','4','5','6','7','8','9','A','B','C','D','X'&#125;;//验证码池 public static Random random = new Random(); //随机数 public static String ranString; public static String getRandomString()&#123; //获取5位随机数，放在图片里 StringBuffer buffer= new StringBuffer(); for(int i=0;i&lt;5;i++)&#123; buffer.append(chars[random.nextInt(chars.length)]); &#125; return buffer.toString(); &#125; public static Color getRandomColor()&#123;//获取随机的颜色 return new Color(random.nextInt(255),random.nextInt(255),random.nextInt(255)); &#125; public static Color getReverseColor(Color c)&#123; //返回某颜色额反色 return new Color(255-c.getRed(),255-c.getGreen(),255-c.getBlue()); &#125; public CodeServlet() &#123; // TODO Auto-generated constructor stub super(); &#125; public void destroy()&#123; super.destroy(); &#125; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"image/jpeg\"); String randomString = getRandomString(); request.getSession(true).setAttribute(\"randomString\", randomString); int width=80; int height=30; Color color = getRandomColor(); //随机颜色，用于背景色 Color reverse = getReverseColor(color); //反色，用于前景色 //创建一个彩色图片 BufferedImage bi = new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB); Graphics2D g = bi.createGraphics(); g.setFont(new Font(Font.SANS_SERIF,Font.BOLD,16)); g.setColor(color); g.fillRect(0,0,width,height); g.setColor(reverse); g.drawString(randomString, 18, 20);//绘制随机字符 for(int i=0,n=random.nextInt(100);i&lt;n;i++)&#123; //画最多100个噪音点 g.drawRect(random.nextInt(width), random.nextInt(height), 1, 1); &#125; ServletOutputStream out= response.getOutputStream();//转成JPEG格式 JPEGImageEncoder encoder=JPEGCodec.createJPEGEncoder(out);//编码器 encoder.encode(bi); //对图片进行编码 out.flush(); //输出到客户端 CodeServlet.ranString = randomString; &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; public void init() throws ServletException &#123; &#125; public boolean sayRandom(String code) &#123; //判断是否生成的验证码一致 if(code.equalsIgnoreCase(ranString)) &#123; return true; &#125; return false; &#125;&#125; 写完这些，我们打开 WebContent 下的 WEB-INF 文件夹下的 web.xml 文件，看看里面有没有： 12345678&lt;servlet&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.db.tools.CodeServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CodeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/com.db.tools/CodeServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 如果没有，则把它添加至 “\\“ 标签的下方。接着在Java Resources–WebContent下新建一个 jsp 页面，在 body 标签下添加一个 img 标签。 1&lt;img src=\"com.mail/CodeServlet\" id=\"identity\" onclick=\"reloadImage()\" /&gt; 接着在WebContent文件夹下新建一个名为 js 的文件夹，在里面建一个名为 code 的 js 文件，在里面添加下面的代码。 123function reloadImage()&#123; document.getElementById('identity').src='com.mail/CodeServlet?ts='+new Date().getTime();&#125; 回到 jsp 页面，引入 code.js 文件。运行一下 jsp 文件，看看页面上会不会出现一个验证码。接着单击验证码，验证码会更改。 邮件功能发送邮件，就是一个邮箱向另一个邮箱发送邮件。所以我们得设定一个发送者的邮箱，接着得到用户的邮箱，编写好发送的内容进行发送。在这里里面不变的常量是发送者的邮箱，发送的内容格式，而会改变的就是用户的邮箱，验证码，所以我们定义两个变量存放用户邮箱和验证码。我使用的是qq邮箱的SMTP服务来发送邮件。接着，我们用代码实现，在Java Resources下的src目录下建一个包，包名为 com.mail ,接着在里面创建一个 Mail 类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Date;import java.util.Properties;import java.util.Random;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.*;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;public class Mail &#123;private String result;private String to; //收件人邮箱public void setTo(String to) &#123; //设置收件人邮箱 this.to = to;&#125;private String randomString;public String getRandom() &#123; //得到随机数 return this.randomString;&#125;public static final char[] chars=&#123;'2','3','4','5','6','7','8','9','A','B','C','D','X'&#125;;//验证码池public static Random random = new Random(); //随机数public static String getRandomString()&#123; //获取5位随机数，放在图片里 StringBuffer buffer= new StringBuffer(); for(int i=0;i&lt;5;i++)&#123; buffer.append(chars[random.nextInt(chars.length)]); &#125; return buffer.toString();&#125; public Boolean sendCode() &#123; // 发件人的电子邮件名和密碼 String from = \"发送者邮箱\"; String psd = \"qq开通SMTP服务后生成的密码\"; //设置用户名 String user = \"发送者邮箱\"; Properties properties = new Properties(); try &#123; // 设置用户的认证方式 properties.setProperty( \"mail.smtp.auth\", \"true\" ); //设置传输协议 properties.setProperty( \"mail.transport.protocol\", \"smtp\" ); //SMTP邮件服务器 properties.setProperty( \"mail.smtp.host\", \"smtp.qq.com\" ); //SMTP邮件服务器默认端口 properties.setProperty( \"mail.smtp.port\", \"587\" ); // 获取默认的Session对象。 Session mailSession = Session.getDefaultInstance( properties ); // 创建一个默认的MimeMessage对象。 Message message = new MimeMessage( mailSession ); // 根据session对象获取邮件传输对象Transport Transport transport = mailSession.getTransport(); // 设置 From: 头部的header字段 message.setFrom( new InternetAddress( from ) ); // 设置 To: 头部的header字段 message.addRecipient( Message.RecipientType.TO, new InternetAddress( to ) ); // 设置 Subject: header字段 message.setSubject( \"邮件的标题\" ); // 现在设置的实际消息 BodyPart messageBodyPart = new MimeBodyPart(); randomString = getRandomString(); //获得随机验证码 messageBodyPart.setText(\"您正在修改密码，请在验证码输入框中输入： \"+randomString+\"，以完成操作。\"); Multipart multipart = new MimeMultipart(); multipart.addBodyPart(messageBodyPart); //发送文件 message.setContent(multipart); message.setSentDate(new Date()); // 设置发件人的账户名和密码 transport.connect(user,psd); // 发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage( message, message.getAllRecipients() ); result = \"Sent message fully....\"; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); result = \"Error: unable to send message....\"; return false; &#125; &#125; public Boolean isCode(String code) &#123; //判断是否与系统生成的验证码一致 System.out.println(randomString); System.out.print(code); if(code.equalsIgnoreCase(randomString)) &#123; return true; &#125; return false; &#125;&#125; 调用 setTo() 方法即可设置收件人邮箱，调用 isCode() 方法判断用户输入的验证码是否与发送的验证码一致。当以上三个功能都做完后，我们就可以开始写页面功能了，我们先在 Java Resources–WebContent 文件夹下把上面提到的几个页面都建好，为下面做准备。首先是注册页面，使用到的是增加。 注册页面打开 register.jsp 文件，引入 code.js 接着建一个 form 表单。 123456789&lt;form action=\"\"&gt; 学号：&lt;input type=\"text\" name=\"u_nub\" id=\"u_nub\"&gt; 姓名：&lt;input type=\"text\" name=\"u_name\" id=\"u_name\"&gt; 邮箱：&lt;input type=\"email\" name=\"u_mail\" id=\"u_mail\"&gt; 密码：&lt;input type=\"password\" name=\"u_pwd\" id=\"u_pwd\"&gt; &lt;input type=text id=\"txtCode\" name=\"txtCode\"&gt; &lt;img src=\"com.mail/CodeServlet\" id=\"identity\" onclick=\"reloadImage()\" /&gt; &lt;input type=\"submit\" value=\"提交\" id=\"post\" name=\"post\"&gt;&lt;/form&gt; 添加完表单后，我们用 js 写一个表单验证。 12345678910111213141516171819202122232425262728293031323334&lt;script type=\"text/javascript\"&gt; var ub = document.getElementById(\"u_nub\"), un = document.getElementById(\"u_name\"), um = document.getElementById(\"u_mail\"), upw = document.getElementById(\"u_pwd\"), code = document.getElementById(\"txtCode\"), post = document.getElementById(\"post\"); function verify()&#123; if(ub.value == \"\")&#123; alert(\"请输入学号\"); ub.focus(); return false; &#125;else if(un.value==\"\")&#123; alert(\"请输入姓名\"); un.focus(); return false; &#125;else if(um.value==\"\")&#123; alert(\"请输入邮箱\"); um.focus(); return false; &#125;else if(upw.value==\"\")&#123; upw.focus(); alert(\"请输入密码\"); return false; &#125;else if(code.value==\"\")&#123; code.focus(); alert(\"请输入验证码\"); return false; &#125;else &#123; return true; &#125; &#125; post.onclick=verify(); &lt;/script&gt; 先运行一下程序，看看能否正常运行网页。 能正常运行，则可以继续往下写了，下面会用到我们之前写的java类，所以我们需要导包，在页面最上方 &lt;%@ page ……%&gt; 中，在最后添加一句“ import=”com.db.tools.,java.sql.“ ”。最终效果如下： 1&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\" import=\"com.db.tools.*,java.sql.*\"%&gt; 这样我们的 jsp 页面才能找到我们的DbUtil类。继续往下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;% //判断用户是否提交 if(request.getParameter(\"post\") != null)&#123; CodeServlet m = new CodeServlet(); //获取前端页面数据 String code = request.getParameter(\"txtCode\"); if(code != null &amp;&amp; code != \"\")&#123; //判断验证码是否正确 if(m.sayRandom(code))&#123; //获取前端页面数据 String uNub = request.getParameter(\"u_nub\"); String uName = request.getParameter(\"u_name\"); String uPwd = request.getParameter(\"u_pwd\"); String uMail = request.getParameter(\"u_mail\"); //创建DbUtil类对象 DbUtil db = new DbUtil(); //创建变量存放sql语句 String sql = \"select * from tb_user where user_number='\"+uNub+\"'\"; //如果在数据库中能查询到当前注册用户的学生，则提示错误 if(db.dbQuery(sql).next())&#123; out.println(\"&lt;script&gt;alert('添加失败，此用户已存在');upw.value=\\\"\\\";upw.focus();&lt;/script&gt;\"); &#125; else&#123; //在数据库中添加该用户 sql = \"insert into tb_user values('123',+'\"+uNub+\"','\"+uName+\"','\"+uMail+\"','\"+uPwd+\"')\"; if(db.dbUpdate(sql))&#123; response.sendRedirect(\"selectStudent.jsp\"); &#125; &#125; &#125; else&#123;%&gt; &lt;script&gt;alert(\"验证码错误\");&lt;/script&gt;&lt;% &#125; &#125; &#125;%&gt; 这样我们的注册页面就完成了，此时可以运行一下是否正常运行。 登陆页面打开 login.jsp ，引入 code.js 文件，接着写一个表单。 123456789&lt;form action=\"\"&gt; 学号：&lt;input type=\"text\" name=\"u_nub\"&gt; 密码：&lt;input type=\"password\" name=\"u_pwd\"&gt; &lt;input type=text id=\"txtCode\" name=\"txtCode\"&gt; &lt;img src=\"com.mail/CodeServlet\" id=\"identity\" onclick=\"reloadImage()\" /&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;a href=\"register.jsp\"&gt;&lt;input type=\"button\" value=\"注册\" name=\"post\"&gt;&lt;/a&gt; &lt;a href=\"forgotPWD.jsp\" class=\"a\"&gt;忘记密码？&lt;/a&gt;&lt;/form&gt; 接着还是用 js 写一个表单验证，我的建议是外链一个 js 文件，里面写一个函数，要用的时候直接调用，避免写重复的代码， input 标签里的 name 和 id 不同的页面但是是同一个数据的可以取相同名。例如注册页面的表单中有学号和密码，登陆页面也有，并且这两个含义相同，则可以取相同的 name 和 id ，这样直接一个函数就搞定了。js 代码搞定后，就是jsp代码，首先像注册页面一样导包，这里也会用到验证码功能，所以依旧是导入 “ com.db.tools.,java.sql. ” 。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;% //判断用户是否提交 if(request.getParameter(\"post\") ！= null)&#123; //判断用户是否有输入学号 if(uName != null &amp;&amp; uName != \"\" )&#123; CodeServlet m = new CodeServlet(); String code = request.getParameter(\"txtCode\"); //获取前端的学号 String uName = request.getParameter(\"u_nub\"); //获取前端的密码 String uPwd = request.getParameter(\"u_pwd\"); //判断用户是否有输入验证码 if(code != null &amp;&amp; code != \"\")&#123; //判断用户输入的验证码是否正确 if(m.sayRandom(code))&#123; //创建sql语句 String sql = \"select * from tb_user where user_number='\"+uName+\"' and user_pwd='\"+uPwd+\"'\"; //创建DbUtil类对象 连接数据库 DbUtil db = new DbUtil(); //创建ResultSet对象，存放结果集 ResultSet rs = db.dbQuery(sql); if(rs.next())&#123; session.setAttribute(\"u_nub\",uName); response.sendRedirect(\"selectStudent.jsp\"); //跳转至查询学生信息界面 &#125;else&#123; out.write(\"登陆失败\"); &#125; &#125; else&#123; %&gt; &lt;script&gt;alert(\"验证码错误\");&lt;/script&gt; &lt;% &#125; &#125; &#125; &#125;%&gt; 以上就是登陆页面的jsp代码，完成后尝试登陆一下，看看能否成功。 找回密码页面找回密码呢，上面也说过，就是要确认用户的身份，是否为本人操作，这就需要验证码功能了。确定为本人后就跳转至设置密码页面，让用户重新设置密码。打开 forgotPWD.jsp 页面，这里就不需要引入 code.js 了，这里需要用到邮箱功能，所以导入的包是“ com.mail,java.sql.,com.db.tools. ”，接着建一个表单。 1234567&lt;form&gt; &lt;input type=\"number\" class=\"textbox\" placeholder=\"请输入学号....\" id=\"u_nub\" name=\"u_nub\"&gt; &lt;input type=\"email\" class=\"textbox\" placeholder=\"请输入邮箱....\" id=\"u_mail\" name=\"u_mail\"&gt; &lt;input type=\"text\" class=\"textcode\" placeholder=\"请输入验证码....\" id=\"txtCode\" name=\"txtCode\"&gt; &lt;button class=\"textbutton\" id=\"sendCode\" name=\"sendCode\" &gt;发送验证码&lt;/button&gt; &lt;input type=\"submit\" class=\"nextstep\" value=\"下一步\" name=\"next\" id=\"next\" &gt;&lt;/form&gt;&lt;a href=\"login.jsp\"&gt;登录&lt;/a&gt;&lt;a href=\"register.jsp\"&gt;注册&lt;/a&gt; 开始写 jsp 代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//创建一个变量，存放验证码&lt;%! String mailCode; %&gt;&lt;%if(request.getParameter(\"sendCode\") != null)&#123; String u_nub = request.getParameter(\"u_nub\"); String u_mail = request.getParameter(\"u_mail\"); if(u_mail != null &amp;&amp; u_mail !=\"\")&#123; DbUtil db = new DbUtil(); String sql = \"select * from tb_user where user_number='\"+u_nub+\"'and user_mail='\"+u_mail+\"'\"; if(db.dbQuery(sql).next())&#123; Mail mail = new Mail(); mail.setTo(u_mail); if(mail.sendCode())&#123; //判断是否发送成功 mailCode=mail.getRandom();%&gt; &lt;script&gt; var num=document.getElementById(\"u_nub\"); var mail=document.getElementById(\"u_mail\"); var sendButton = document.getElementById(\"sendCode\"); function sendSuccess()&#123; alert(\"发送成功\"); sendButton.setAttribute(\"disabled\", true); //发送按钮不可用 zhi(); &#125; function sendFailure()&#123; alert(\"发送失败\"); zhi(); &#125; sendSuccess(); function zhi()&#123; num.value=\"&lt;%=u_nub%&gt;\"; mail.value=\"&lt;%=u_mail%&gt;\"; &#125; &lt;/script&gt;&lt;% System.out.println(\"邮箱：\"+u_mail+\"发送成功\"); &#125; else&#123; System.out.println(\"邮箱：\"+u_mail+\"发送失败\");%&gt; &lt;script&gt;sendFailure();&lt;/script&gt;&lt;% &#125; &#125; else&#123;%&gt; &lt;script&gt;alert(\"用户不存在或邮箱错误\");&lt;/script&gt;&lt;% &#125; &#125; &#125; if(request.getParameter(\"next\") != null)&#123; String code = request.getParameter(\"txtCode\"); if(code != null &amp;&amp; code != \"\" &amp;&amp; mailCode !=null)&#123; if(mailCode.equalsIgnoreCase(code))&#123; session.setAttribute(\"u_number\", u_nub); response.sendRedirect(\"setPWD.jsp\"); //验证码正确则跳转至设置密码页面 &#125; else&#123;%&gt; &lt;script&gt;alert(\"验证码错误\");&lt;/script&gt;&lt;% &#125; &#125; &#125;%&gt; 这就是找回密码页面啦，身份识别正确则跳转至 setPWD.jsp 页面。 设置密码页面打开 setPWD.jsp 页面，同样的步骤，导包、建表单。 1234567&lt;form&gt; &lt;input type=\"password\" class=\"textbox1\" placeholder=\"请输入新密码....\" name=\"u_pwd\"&gt; &lt;input type=\"password\" class=\"textbox1\" placeholder=\"请再次输入新密码....\" id=\"passwords\" name=\"u_pwds\"&gt; &lt;input type=\"submit\" class=\"back1\" value=\"确定\" name=\"ok\"&gt;&lt;/form&gt;&lt;a href=\"login.jsp\"&gt;登录&lt;/a&gt;&lt;a href=\"register.jsp\"&gt;注册&lt;/a&gt; 因为我们不能让用户随便就访问到这个页面，所以得设置一个拦截器，让不是从 forgotPWD.jsp 页面跳转过来，而是直接访问这个页面的用户自动跳转至 forgotPWD.jsp 页面。这里我使用的是 判断 session 的值是否为空的方法，因为forgotPWD.jsp 跳转时会将学号传到 setPWD.jsp 页面，这也算是一种思路吧。 123456789101112131415161718192021222324252627&lt;% if(session.getAttribute(\"u_number\")==null)&#123; response.sendRedirect(\"login.jsp\"); &#125; else&#123; if(request.getParameter(\"post\") != null)&#123; String password=request.getParameter(\"u_pwd\"),passwords=request.getParameter(\"u_pwds\"); if(password.equals(passwords) &amp;&amp; password != \"\" &amp;&amp; password != null)&#123; String u_number = (String)session.getAttribute(\"u_number\"); String sql = \"Update tb_user set user_pwd = '\"+passwords+\"' where user_number='\"+u_number+\"'\"; DbUtil db = new DbUtil(); if(db.dbUpdate(sql))&#123; System.out.println(\"修改成功\");%&gt; &lt;script&gt;alert(\"修改成功\");&lt;/scripot&gt;&lt;% response.sendRedirect(\"login.jsp\"); &#125; &#125; else&#123;%&gt; &lt;script&gt;alert(\"两次密码输入不一致\")&lt;/script&gt;&lt;% &#125; &#125; &#125;%&gt; 到这里，增删查改四个步骤已经实现了增加、查询、修改了，就剩下最后一个删除。后面的页面，我就放上代码，也不说太多了，毕竟大部分都是相同的，只是操作的表不同。 删除学生页面其实，删除学生的页面是打不开的，里面只放了一段 jsp 代码。用户在 selectStudent.jsp 这个查看所有学生信息页面的操作一栏中，点击删除，即把那条学生信息的学号传给删除学生页面（delStudent.jsp）, delStudent.jsp 接收到学号，就在数据库中删除掉学生信息。 123456789101112&lt;% if(session.getAttribute(\"u_nub\") == null)&#123; response.sendRedirect(\"login.jsp\"); &#125; String stNo = request.getParameter(\"st_no\"); String sql = \"DELETE FROM tb_student WHERE stuNo='\"+stNo+\"'\"; DbUtil db = new DbUtil(); if(db.dbUpdate(sql))&#123; response.sendRedirect(\"selectStudent.jsp\"); out.println(\"删除成功！\"); &#125;%&gt; 这也是十分简单了。 修改个人信息页面12345678910&lt;form&gt; 学号：&lt;input type=\"text\" class=\"stuid\" name=\"u_nub\" id=\"u_nub\" disabled&gt; 姓名：&lt;input type=\"text\" class=\"stuid\" name=\"u_name\" id=\"u_name\"&gt;&lt;br /&gt; &lt;br /&gt; &lt;br /&gt; &lt;div class=\"stusex\"&gt; 性别：&lt;input type=\"radio\" name=\"sex\" value=\"男\" class=\"stusex1\" id=\"sex1\"&gt;&amp;nbsp;&amp;nbsp;男 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;input type=\"radio\" name=\"sex\" id=\"sex2\" value=\"女\" class=\"stusex1\" checked=\"checked\"&gt;&amp;nbsp;&amp;nbsp;女 &lt;/div&gt; 出生日期：&lt;input type=\"date\" class=\"stuage\" name=\"u_bty\" id=\"u_bty\"&gt;&lt;br /&gt; 邮箱：&lt;input type=\"email\" class=\"emails\" name=\"u_mail\" id=\"u_mail\"&gt;&lt;br /&gt; &lt;a href=\"personManages.jsp\"&gt;&lt;input type=\"button\" value=\"重置\" class=\"stubtu\" name=\"reduction\"&gt;&lt;/a&gt; &lt;input type=\"submit\" value=\"提交\" class=\"stubtu\" name=\"post\"&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;% String uNum = (String)session.getAttribute(\"u_nub\"); if(uNum != null)&#123; //判断用户是否是已登陆状态 String uName; String uSex; String uBty; String uMail; String sql = \" select * from tb_user where user_number='\"+uNum+\"'\"; DbUtil db = new DbUtil(); ResultSet rs=db.dbQuery(sql); if(rs.next())&#123; //rs 1.id 2.学号 3.姓名 4.性别 5.生日 6.邮箱 uName = rs.getString(3); uSex = rs.getString(4); uBty = rs.getString(5); uMail = rs.getString(6); %&gt; &lt;script type=\"text/javascript\"&gt; document.getElementById(\"u_nub\").value=\"&lt;%=uNum%&gt;\"; document.getElementById(\"u_name\").value=\"&lt;%=uName%&gt;\"; document.getElementById(\"u_bty\").value=\"&lt;%=uBty%&gt;\"; document.getElementById(\"u_mail\").value=\"&lt;%=uMail%&gt;\"; var sex1 = document.getElementById(\"sex1\"); var sex2 = document.getElementById('sex2'); var usex = \"&lt;%=uSex%&gt;\"; if(usex == '女')&#123; sex2.setAttribute(\"checked\",\"checked\"); &#125; else&#123; sex1.setAttribute(\"checked\",\"checked\"); &#125; &lt;/script&gt; &lt;% &#125; if(request.getParameter(\"post\") != null)&#123; //判断用户是否点击提交按钮%&gt; &lt;script type=\"text/javascript\"&gt; var confirm = confirm(\"确定修改吗？\"); if(confirm)&#123;&lt;% String upSql = \"update tb_user set user_name='\"+request.getParameter(\"u_name\")+\"',user_sex='\"+request.getParameter(\"sex\")+\"',user_mail='\"+request.getParameter(\"u_mail\")+\"',user_birthday='\"+request.getParameter(\"u_bty\")+\"' where user_number='\"+uNum+\"'\"; if(db.dbUpdate(upSql))&#123; //判断是否更新成功%&gt; alert(\"修改成功\"); window.location=\"personManages.jsp\"; &#125; else&#123; alert(\"修改失败\"); &#125; &lt;/script&gt; &lt;% &#125; &#125; &#125; else&#123; response.sendRedirect(\"login.jsp\"); &#125; if(request.getParameter(\"outLogin\") != null)&#123; //退出登录按钮 session.invalidate(); response.sendRedirect(\"login.jsp\"); &#125;%&gt; 查看学生信息页面123456789101112131415161718192021222324252627282930313233343536373839&lt;% if(session.getAttribute(\"u_nub\") == null)&#123; response.sendRedirect(\"login.jsp\"); &#125; String sql = \" select * from tb_student\"; DbUtil db = new DbUtil(); ResultSet rs=db.dbQuery(sql);%&gt; &lt;table class=\"table\" cellspacing=\"0\"&gt; &lt;tr class=\"th\"&gt; &lt;td&gt;学号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;户籍&lt;/td&gt; &lt;td&gt;出生日期&lt;/td&gt; &lt;td&gt;班级&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt;&lt;% while(rs.next())&#123;%&gt; &lt;tr name=\"data\" class=\"tr_bg\"&gt; &lt;td class=\"tr_id\"&gt;&lt;%=rs.getString(1) %&gt;&lt;/td&gt; &lt;td class=\"tr_txt\"&gt;&lt;%=rs.getString(2) %&gt;&lt;/td&gt; &lt;td class=\"tr_txt\"&gt;&lt;%=rs.getString(3)%&gt;&lt;/td&gt; &lt;td class=\"tr_txt\"&gt;&lt;%=rs.getString(4)%&gt;&lt;/td&gt; &lt;td class=\"tr_txt\"&gt;&lt;%=rs.getString(5)%&gt;&lt;/td&gt; &lt;td class=\"tr_txt\"&gt;&lt;%=rs.getString(6)%&gt;&lt;/td&gt; &lt;td class=\"tr_txt\"&gt; &lt;a href=\"delete.jsp?st_no=&lt;%=rs.getString(1) %&gt;\" onclick=\"return confirm('你确认要删除姓名为：&lt;%=rs.getString(2) %&gt;的数据吗？')\"&gt;删除&lt;/a&gt; &lt;a href=\"stuinfUpdate.jsp?stNo=&lt;%=rs.getString(1)%&gt;\"&gt;修改&lt;/a&gt; &lt;a href=\"addStudent.jsp\"&gt;添加学生&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt;&lt;% &#125;%&gt; &lt;/table&gt; 添加学生信息页面12345678910&lt;form class=\"form\"&gt; 学号：&lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_No\" id=\"st_No\"&gt; 姓名： &lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_name\" id=\"st_name\"&gt; 性别： &lt;input type=\"radio\" name=\"sex\" value=\"男\" class=\"stuformsex\" checked=\"checked\"&gt;&amp;nbsp;&amp;nbsp;男&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type=\"radio\" name=\"sex\" value=\"女\" class=\"stuformsex\"&gt;&amp;nbsp;&amp;nbsp;女 出生日期： &lt;input type=\"date\" align=\"left\" class=\"input\"name=\"st_bty\" id=\"st_bty\"&gt; 户籍： &lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_Place\" id=\"st_Place\"&gt; 班级： &lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_claName\" id=\"st_claName\"&gt; &lt;button class=\"stuformbut\" onclick=\"return verify();\"&gt;提交&lt;/button&gt; &lt;button class=\"stuformbut\" onclick=\"javascript:window.location.href='selectStudent.jsp'\"&gt;返回&lt;/button&gt;&lt;/form&gt; 1234567891011121314151617181920212223&lt;% if(session.getAttribute(\"u_nub\") == null)&#123; response.sendRedirect(\"login.jsp\"); &#125; if(request.getParameter(\"st_No\") != null &amp;&amp; request.getParameter(\"st_No\") != \"\")&#123; String stNo = request.getParameter(\"st_No\"); String stName = request.getParameter(\"st_name\"); String stSex = request.getParameter(\"sex\"); String stPlac = request.getParameter(\"st_Place\"); String stByt = request.getParameter(\"st_bty\"); String stClna = request.getParameter(\"st_claName\"); DbUtil db = new DbUtil(); String sql = \"select * from tb_student where stuNo='\"+stNo+\"'\"; if(db.dbQuery(sql).next())&#123; out.println(\"&lt;script&gt;alert('添加失败，学号已存在');&lt;/script&gt;\"); &#125;else&#123; sql = \"insert into tb_student values('\"+stNo+\"','\"+stName+\"','\"+stSex+\"','\"+stPlac+\"','\"+stByt+\"','\"+stClna+\"')\"; if(db.dbUpdate(sql))&#123; response.sendRedirect(\"stuinFormation.jsp\"); &#125; &#125; &#125;%&gt; 修改学生信息页面12345678910&lt;form class=\"form\"&gt; 学号：&lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_No\" id=\"st_No\"&gt; 姓名： &lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_name\" id=\"st_name\"&gt; 性别： &lt;input type=\"radio\" name=\"sex\" value=\"男\" class=\"stuformsex\" checked=\"checked\"&gt;&amp;nbsp;&amp;nbsp;男&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &lt;input type=\"radio\" name=\"sex\" value=\"女\" class=\"stuformsex\"&gt;&amp;nbsp;&amp;nbsp;女 出生日期： &lt;input type=\"date\" align=\"left\" class=\"input\"name=\"st_bty\" id=\"st_bty\"&gt; 户籍： &lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_Place\" id=\"st_Place\"&gt; 班级： &lt;input type=\"text\" align=\"left\" class=\"input\" name=\"st_claName\" id=\"st_claName\"&gt; &lt;button class=\"stuformbut\" onclick=\"return verify();\"&gt;提交&lt;/button&gt; &lt;button class=\"stuformbut\" onclick=\"javascript:window.location.href='selectStudent.jsp'\"&gt;返回&lt;/button&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;% String stNo = (String)session.getAttribute(\"stNo\"); DbUtil db = new DbUtil(); if(session.getAttribute(\"u_nub\") == null)&#123; response.sendRedirect(\"login.jsp\"); &#125; if(request.getParameter(\"stNo\") != null)&#123; stNo = request.getParameter(\"stNo\"); session.setAttribute(\"stNo\", stNo); String sql = \"select * from tb_student where stuNo='\"+stNo+\"'\"; ResultSet rs = db.dbQuery(sql); if(rs.next())&#123;%&gt; &lt;script&gt; document.getElementById(\"st_No\").value=\"&lt;%=rs.getString(1)%&gt;\"; document.getElementById(\"st_name\").value=\"&lt;%=rs.getString(2)%&gt;\"; var usex = \"&lt;%=rs.getString(3)%&gt;\"; if(usex == '女')&#123; sex2.setAttribute(\"checked\",\"checked\"); &#125; else&#123; sex1.setAttribute(\"checked\",\"checked\"); &#125; document.getElementById(\"st_Place\").value=\"&lt;%=rs.getString(4)%&gt;\"; document.getElementById(\"st_bty\").value=\"&lt;%=rs.getString(5)%&gt;\"; document.getElementById(\"st_claName\").value=\"&lt;%=rs.getString(6)%&gt;\"; &lt;/script&gt;&lt;% &#125; &#125; if(request.getParameter(\"post\")!=null &amp;&amp; stNo != null)&#123; String sql = \"update tb_student set stu_Name='\"+request.getParameter(\"st_name\")+\"',stu_sex='\"+request.getParameter(\"st_sex\")+\"',stu_nativeplace='\"+request.getParameter(\"st_Place\")+\"',stu_birthday='\"+request.getParameter(\"st_bty\")+\"',stu_classname='\"+request.getParameter(\"st_claName\")+\"' where stuNo='\"+stNo+\"'\"; if(db.dbUpdate(sql))&#123; response.sendRedirect(\"stuinfManages.jsp\");%&gt; &lt;script type=\"text/javascript\"&gt;alert(\"修改成功\");&lt;/script&gt;&lt;% &#125; else&#123;%&gt; &lt;script type=\"text/javascript\"&gt;alert(\"修改失败\");&lt;/script&gt;&lt;% &#125; &#125;%&gt; END至此，差不多整个项目的雏形已经出来了，就是差一个页面的美化。不知不觉写了这么多，到后面其实已经有点累了，一度想着要不算了，反正都是重复的，还好没有放弃，还是把所有的页面代码贴了出来，尽管没有刚开始写的那么详细，但是我相信前面要是认认真真看了的，后面的肯定也会理解的。这个项目就告一段落啦，后面还想着会用 spring 重写一遍，在这里立一个 flag 。","categories":[{"name":"JSP","slug":"JSP","permalink":"https://04071011.xyz/categories/JSP/"}],"tags":[{"name":"JSP","slug":"JSP","permalink":"https://04071011.xyz/tags/JSP/"},{"name":"作业项目","slug":"作业项目","permalink":"https://04071011.xyz/tags/作业项目/"},{"name":"2019","slug":"2019","permalink":"https://04071011.xyz/tags/2019/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-15T15:39:05.459Z","updated":"2019-01-19T11:55:25.799Z","comments":true,"path":"2019/01/15/hello-world/","link":"","permalink":"https://04071011.xyz/2019/01/15/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1234567891011121314151617181920212223242526272829303132333435363738394041424344$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generatehighlighthighlighthighlighthighlighthighlighthighlighthighlighthighlighthighlighthighlighthighlighthighlighthighlight$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}